unit BlendShader;
{ #version:1# (machine generated, don't edit!)

  Generated by sokol-shdc (https://github.com/floooh/sokol-tools)
  With Delphi modifications (https://github.com/neslib/Neslib.Sokol.Tools)

  Cmdline: sokol-shdc --input BlendShader.glsl --output BlendShader.pas

  Overview:

    Shader program 'bg':
      Get shader desc: BgShaderDesc()
      Vertex shader: vs_bg
        Attribute slots:
          ATTR_VS_BG_POSITION = 0
      Fragment shader: fs_bg
        Uniform block 'bg_fs_params':
          Delphi record: TBGFsParams
          Bind slot: SLOT_BG_FS_PARAMS = 0

    Shader program 'quad':
      Get shader desc: QuadShaderDesc()
      Vertex shader: vs_quad
        Attribute slots:
          ATTR_VS_QUAD_POSITION = 0
          ATTR_VS_QUAD_COLOR0 = 1
        Uniform block 'quad_vs_params':
          Delphi record: TQuadVsParams
          Bind slot: SLOT_QUAD_VS_PARAMS = 0
      Fragment shader: fs_quad


  Shader descriptor records:

    var BgShader := TShader.Create(BgShaderDesc);
    var QuadShader := TShader.Create(QuadShaderDesc);

  Vertex attribute locations for vertex shader 'vs_bg':

    var PipDesc: TPipelineDesc;
    PipDesc.Init;
    PipDesc.Attrs[ATTR_VS_BG_POSITION]. ...
    PipDesc. ...
    var Pip := TPipeline.Create(PipDesc);

  Vertex attribute locations for vertex shader 'vs_quad':

    var PipDesc: TPipelineDesc;
    PipDesc.Init;
    PipDesc.Attrs[ATTR_VS_QUAD_POSITION]. ...
    PipDesc.Attrs[ATTR_VS_QUAD_COLOR0]. ...
    PipDesc. ...
    var Pip := TPipeline.Create(PipDesc);

  Image bind slots, use as index in TBindings.VSImages[] or .FSImages[]:


  Bind slot and Delphi record for uniform block 'BGFsParams':

    BGFsParams: TBGFsParams;
    BGFsParams.Tick := ...;
    TGfx.ApplyUniforms(TShaderStage.[VertexShader|FragmentShader], SLOT_BG_FS_PARAMS, TRange.Create(BGFsParams));

  Bind slot and Delphi record for uniform block 'QuadVsParams':

    QuadVsParams: TQuadVsParams;
    QuadVsParams.Mvp := ...;
    TGfx.ApplyUniforms(TShaderStage.[VertexShader|FragmentShader], SLOT_QUAD_VS_PARAMS, TRange.Create(QuadVsParams));

}

{$INCLUDE 'Neslib.Sokol.inc'}

interface

uses
  Neslib.FastMath,
  Neslib.Sokol.Gfx;

const
  ATTR_VS_BG_POSITION = 0;
  ATTR_VS_QUAD_POSITION = 0;
  ATTR_VS_QUAD_COLOR0 = 1;

const
  SLOT_BG_FS_PARAMS = 0;

type
  TBGFsParams = packed record
  public
    Tick: Single;
    _Pad4: array [0..11] of UInt8;
  end;

const
  SLOT_QUAD_VS_PARAMS = 0;

type
  TQuadVsParams = packed record
  public
    Mvp: TMatrix4;
  end;

function BgShaderDesc: PNativeShaderDesc;
function QuadShaderDesc: PNativeShaderDesc;

implementation

uses
  Neslib.Sokol.Api;

{$IFDEF SOKOL_GLCORE33}
const
  VS_BG_SOURCE_GLSL330 =
    '#version 330'#10+

    'layout(location = 0) in vec2 position;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = vec4(position, 0.5, 1.0);'#10+
    '}';

const
  FS_BG_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform vec4 bg_fs_params[1];'#10+
    'layout(location = 0) out vec4 frag_color;'#10+

    'void main()'#10+
    '{'#10+
    '    vec2 _30 = fract((gl_FragCoord.xy - vec2(bg_fs_params[0].x)) * vec2(0.0199999995529651641845703125));'#10+
    '    float _41 = _30.x * _30.y;'#10+
    '    frag_color = vec4(_41, _41, _41, 1.0);'#10+
    '}';

const
  VS_QUAD_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform vec4 quad_vs_params[4];'#10+
    'layout(location = 0) in vec4 position;'#10+
    'out vec4 color;'#10+
    'layout(location = 1) in vec4 color0;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(quad_vs_params[0], quad_vs_params[1], quad_vs_params[2], quad_vs_params[3]) * position;'#10+
    '    color = color0;'#10+
    '}';

const
  FS_QUAD_SOURCE_GLSL330 =
    '#version 330'#10+

    'layout(location = 0) out vec4 frag_color;'#10+
    'in vec4 color;'#10+

    'void main()'#10+
    '{'#10+
    '    frag_color = color;'#10+
    '}';

{$ENDIF !SOKOL_GLCORE33}

{$IFDEF SOKOL_GLES2}
const
  VS_BG_SOURCE_GLSL100 =
    '#version 100'#10+

    'attribute vec2 position;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = vec4(position, 0.5, 1.0);'#10+
    '}';

const
  FS_BG_SOURCE_GLSL100 =
    '#version 100'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'uniform highp vec4 bg_fs_params[1];'#10+
    'void main()'#10+
    '{'#10+
    '    highp vec2 _30 = fract((gl_FragCoord.xy - vec2(bg_fs_params[0].x)) * vec2(0.0199999995529651641845703125));'#10+
    '    highp float _41 = _30.x * _30.y;'#10+
    '    gl_FragData[0] = vec4(_41, _41, _41, 1.0);'#10+
    '}';

const
  VS_QUAD_SOURCE_GLSL100 =
    '#version 100'#10+

    'uniform vec4 quad_vs_params[4];'#10+
    'attribute vec4 position;'#10+
    'varying vec4 color;'#10+
    'attribute vec4 color0;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(quad_vs_params[0], quad_vs_params[1], quad_vs_params[2], quad_vs_params[3]) * position;'#10+
    '    color = color0;'#10+
    '}';

const
  FS_QUAD_SOURCE_GLSL100 =
    '#version 100'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'varying highp vec4 color;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_FragData[0] = color;'#10+
    '}';

{$ENDIF !SOKOL_GLES2}

{$IFDEF SOKOL_GLES3}
const
  VS_BG_SOURCE_GLSL300ES =
    '#version 300 es'#10+

    'layout(location = 0) in vec2 position;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = vec4(position, 0.5, 1.0);'#10+
    '}';

const
  FS_BG_SOURCE_GLSL300ES =
    '#version 300 es'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'uniform highp vec4 bg_fs_params[1];'#10+
    'layout(location = 0) out highp vec4 frag_color;'#10+

    'void main()'#10+
    '{'#10+
    '    highp vec2 _30 = fract((gl_FragCoord.xy - vec2(bg_fs_params[0].x)) * vec2(0.0199999995529651641845703125));'#10+
    '    highp float _41 = _30.x * _30.y;'#10+
    '    frag_color = vec4(_41, _41, _41, 1.0);'#10+
    '}';

const
  VS_QUAD_SOURCE_GLSL300ES =
    '#version 300 es'#10+

    'uniform vec4 quad_vs_params[4];'#10+
    'layout(location = 0) in vec4 position;'#10+
    'out vec4 color;'#10+
    'layout(location = 1) in vec4 color0;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(quad_vs_params[0], quad_vs_params[1], quad_vs_params[2], quad_vs_params[3]) * position;'#10+
    '    color = color0;'#10+
    '}';

const
  FS_QUAD_SOURCE_GLSL300ES =
    '#version 300 es'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'layout(location = 0) out highp vec4 frag_color;'#10+
    'in highp vec4 color;'#10+

    'void main()'#10+
    '{'#10+
    '    frag_color = color;'#10+
    '}';

{$ENDIF !SOKOL_GLES3}

{$IFDEF SOKOL_D3D11}
const
  VS_BG_SOURCE_HLSL5 =
    'static float4 gl_Position;'#10+
    'static float2 position;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float2 position : TEXCOORD0;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 gl_Position : SV_Position;'#10+
    '};'#10+

    'void vert_main()'#10+
    '{'#10+
    '    gl_Position = float4(position, 0.5f, 1.0f);'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    position = stage_input.position;'#10+
    '    vert_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.gl_Position = gl_Position;'#10+
    '    return stage_output;'#10+
    '}';

const
  FS_BG_SOURCE_HLSL5 =
    'cbuffer bg_fs_params : register(b0)'#10+
    '{'#10+
    '    float _19_tick : packoffset(c0);'#10+
    '};'#10+


    'static float4 gl_FragCoord;'#10+
    'static float4 frag_color;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float4 gl_FragCoord : SV_Position;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 frag_color : SV_Target0;'#10+
    '};'#10+

    'void frag_main()'#10+
    '{'#10+
    '    float2 _30 = frac((gl_FragCoord.xy - _19_tick.xx) * 0.0199999995529651641845703125f.xx);'#10+
    '    float _41 = _30.x * _30.y;'#10+
    '    frag_color = float4(_41, _41, _41, 1.0f);'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    gl_FragCoord = stage_input.gl_FragCoord;'#10+
    '    gl_FragCoord.w = 1.0 / gl_FragCoord.w;'#10+
    '    frag_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.frag_color = frag_color;'#10+
    '    return stage_output;'#10+
    '}';

const
  VS_QUAD_SOURCE_HLSL5 =
    'cbuffer quad_vs_params : register(b0)'#10+
    '{'#10+
    '    row_major float4x4 _21_mvp : packoffset(c0);'#10+
    '};'#10+


    'static float4 gl_Position;'#10+
    'static float4 position;'#10+
    'static float4 color;'#10+
    'static float4 color0;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float4 position : TEXCOORD0;'#10+
    '    float4 color0 : TEXCOORD1;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 color : TEXCOORD0;'#10+
    '    float4 gl_Position : SV_Position;'#10+
    '};'#10+

    'void vert_main()'#10+
    '{'#10+
    '    gl_Position = mul(position, _21_mvp);'#10+
    '    color = color0;'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    position = stage_input.position;'#10+
    '    color0 = stage_input.color0;'#10+
    '    vert_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.gl_Position = gl_Position;'#10+
    '    stage_output.color = color;'#10+
    '    return stage_output;'#10+
    '}';

const
  FS_QUAD_SOURCE_HLSL5 =
    'static float4 frag_color;'#10+
    'static float4 color;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float4 color : TEXCOORD0;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 frag_color : SV_Target0;'#10+
    '};'#10+

    'void frag_main()'#10+
    '{'#10+
    '    frag_color = color;'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    color = stage_input.color;'#10+
    '    frag_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.frag_color = frag_color;'#10+
    '    return stage_output;'#10+
    '}';

{$ENDIF !SOKOL_D3D11}

{$IFDEF SOKOL_METAL}
const
  VS_BG_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 position [[attribute(0)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = float4(in.position, 0.5, 1.0);'#10+
    '    return out;'#10+
    '}';

const
  FS_BG_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct bg_fs_params'#10+
    '{'#10+
    '    float tick;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'fragment main0_out main0(constant bg_fs_params& _19 [[buffer(0)]], float4 gl_FragCoord [[position]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    float2 _30 = fract((gl_FragCoord.xy - float2(_19.tick)) * float2(0.0199999995529651641845703125));'#10+
    '    float _41 = _30.x * _30.y;'#10+
    '    out.frag_color = float4(_41, _41, _41, 1.0);'#10+
    '    return out;'#10+
    '}';

const
  VS_QUAD_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct quad_vs_params'#10+
    '{'#10+
    '    float4x4 mvp;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 color [[user(locn0)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 position [[attribute(0)]];'#10+
    '    float4 color0 [[attribute(1)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant quad_vs_params& _21 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = _21.mvp * in.position;'#10+
    '    out.color = in.color0;'#10+
    '    return out;'#10+
    '}';

const
  FS_QUAD_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 color [[user(locn0)]];'#10+
    '};'#10+

    'fragment main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.frag_color = in.color;'#10+
    '    return out;'#10+
    '}';

{$ENDIF !SOKOL_METAL}

{$IFDEF SOKOL_METAL}
const
  VS_BG_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 position [[attribute(0)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = float4(in.position, 0.5, 1.0);'#10+
    '    return out;'#10+
    '}';

const
  FS_BG_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct bg_fs_params'#10+
    '{'#10+
    '    float tick;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'fragment main0_out main0(constant bg_fs_params& _19 [[buffer(0)]], float4 gl_FragCoord [[position]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    float2 _30 = fract((gl_FragCoord.xy - float2(_19.tick)) * float2(0.0199999995529651641845703125));'#10+
    '    float _41 = _30.x * _30.y;'#10+
    '    out.frag_color = float4(_41, _41, _41, 1.0);'#10+
    '    return out;'#10+
    '}';

const
  VS_QUAD_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct quad_vs_params'#10+
    '{'#10+
    '    float4x4 mvp;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 color [[user(locn0)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 position [[attribute(0)]];'#10+
    '    float4 color0 [[attribute(1)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant quad_vs_params& _21 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = _21.mvp * in.position;'#10+
    '    out.color = in.color0;'#10+
    '    return out;'#10+
    '}';

const
  FS_QUAD_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 color [[user(locn0)]];'#10+
    '};'#10+

    'fragment main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.frag_color = in.color;'#10+
    '    return out;'#10+
    '}';

{$ENDIF !SOKOL_METAL}

var
  GBgShaderDesc: TNativeShaderDesc;

procedure InitBgShaderDesc;
begin
  GBgShaderDesc.Init;
  GBgShaderDesc.Attrs[0].Init('position', 'TEXCOORD', 0);

  case TGfx.Backend of
    {$IFDEF SOKOL_GLCORE33}
    TBackend.GLCore33:
      begin
        GBgShaderDesc.VS.Source := VS_BG_SOURCE_GLSL330;
        GBgShaderDesc.FS.Source := FS_BG_SOURCE_GLSL330;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES2}
    TBackend.Gles2:
      begin
        GBgShaderDesc.VS.Source := VS_BG_SOURCE_GLSL100;
        GBgShaderDesc.FS.Source := FS_BG_SOURCE_GLSL100;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES3}
    TBackend.Gles3:
      begin
        GBgShaderDesc.VS.Source := VS_BG_SOURCE_GLSL300ES;
        GBgShaderDesc.FS.Source := FS_BG_SOURCE_GLSL300ES;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_D3D11}
    TBackend.D3D11:
      begin
        GBgShaderDesc.VS.Source := VS_BG_SOURCE_HLSL5;
        GBgShaderDesc.FS.Source := FS_BG_SOURCE_HLSL5;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalMacOS:
      begin
        GBgShaderDesc.VS.Source := VS_BG_SOURCE_METAL_MACOS;
        GBgShaderDesc.FS.Source := FS_BG_SOURCE_METAL_MACOS;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalIOS:
      begin
        GBgShaderDesc.VS.Source := VS_BG_SOURCE_METAL_IOS;
        GBgShaderDesc.FS.Source := FS_BG_SOURCE_METAL_IOS;
      end;
    {$ENDIF}
  else
    Assert(False)
  end;

  GBgShaderDesc.fs.uniform_blocks[0].size := 16;
  GBgShaderDesc.fs.uniform_blocks[0].layout := _SG_UNIFORMLAYOUT_STD140;
  if (TGfx.Backend.IsGL) then
    GBgShaderDesc.fs.uniform_blocks[0].uniforms[0].Init('bg_fs_params', _SG_UNIFORMTYPE_FLOAT4, 1);
  GBgShaderDesc.&label := 'BgShader';
end;

function BgShaderDesc: PNativeShaderDesc;
begin
  if (GBgShaderDesc.VS.Entry = nil) then
    InitBgShaderDesc;

  Result := @GBgShaderDesc;
end;


var
  GQuadShaderDesc: TNativeShaderDesc;

procedure InitQuadShaderDesc;
begin
  GQuadShaderDesc.Init;
  GQuadShaderDesc.Attrs[0].Init('position', 'TEXCOORD', 0);
  GQuadShaderDesc.Attrs[1].Init('color0', 'TEXCOORD', 1);

  case TGfx.Backend of
    {$IFDEF SOKOL_GLCORE33}
    TBackend.GLCore33:
      begin
        GQuadShaderDesc.VS.Source := VS_QUAD_SOURCE_GLSL330;
        GQuadShaderDesc.FS.Source := FS_QUAD_SOURCE_GLSL330;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES2}
    TBackend.Gles2:
      begin
        GQuadShaderDesc.VS.Source := VS_QUAD_SOURCE_GLSL100;
        GQuadShaderDesc.FS.Source := FS_QUAD_SOURCE_GLSL100;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES3}
    TBackend.Gles3:
      begin
        GQuadShaderDesc.VS.Source := VS_QUAD_SOURCE_GLSL300ES;
        GQuadShaderDesc.FS.Source := FS_QUAD_SOURCE_GLSL300ES;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_D3D11}
    TBackend.D3D11:
      begin
        GQuadShaderDesc.VS.Source := VS_QUAD_SOURCE_HLSL5;
        GQuadShaderDesc.FS.Source := FS_QUAD_SOURCE_HLSL5;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalMacOS:
      begin
        GQuadShaderDesc.VS.Source := VS_QUAD_SOURCE_METAL_MACOS;
        GQuadShaderDesc.FS.Source := FS_QUAD_SOURCE_METAL_MACOS;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalIOS:
      begin
        GQuadShaderDesc.VS.Source := VS_QUAD_SOURCE_METAL_IOS;
        GQuadShaderDesc.FS.Source := FS_QUAD_SOURCE_METAL_IOS;
      end;
    {$ENDIF}
  else
    Assert(False)
  end;

  GQuadShaderDesc.vs.uniform_blocks[0].size := 64;
  GQuadShaderDesc.vs.uniform_blocks[0].layout := _SG_UNIFORMLAYOUT_STD140;
  if (TGfx.Backend.IsGL) then
    GQuadShaderDesc.vs.uniform_blocks[0].uniforms[0].Init('quad_vs_params', _SG_UNIFORMTYPE_FLOAT4, 4);
  GQuadShaderDesc.&label := 'QuadShader';
end;

function QuadShaderDesc: PNativeShaderDesc;
begin
  if (GQuadShaderDesc.VS.Entry = nil) then
    InitQuadShaderDesc;

  Result := @GQuadShaderDesc;
end;

end.
