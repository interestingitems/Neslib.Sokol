unit CubeMapRTShader;
{ #version:1# (machine generated, don't edit!)

  Generated by sokol-shdc (https://github.com/floooh/sokol-tools)
  With Delphi modifications (https://github.com/neslib/Neslib.Sokol.Tools)

  Cmdline: sokol-shdc --input CubeMapRTShader.glsl --output CubeMapRTShader.pas

  Overview:

    Shader program 'cube':
      Get shader desc: CubeShaderDesc()
      Vertex shader: vs
        Attribute slots:
          ATTR_VS_POS = 0
          ATTR_VS_NORM = 1
        Uniform block 'shape_uniforms':
          Delphi record: TShapeUniforms
          Bind slot: SLOT_SHAPE_UNIFORMS = 0
      Fragment shader: fs_cube
        Image 'tex':
          Type: _SG_IMAGETYPE_CUBE
          Component Type: _SG_SAMPLERTYPE_FLOAT
          Bind slot: SLOT_TEX = 0

    Shader program 'shapes':
      Get shader desc: ShapesShaderDesc()
      Vertex shader: vs
        Attribute slots:
          ATTR_VS_POS = 0
          ATTR_VS_NORM = 1
        Uniform block 'shape_uniforms':
          Delphi record: TShapeUniforms
          Bind slot: SLOT_SHAPE_UNIFORMS = 0
      Fragment shader: fs_shapes


  Shader descriptor records:

    var CubeShader := TShader.Create(CubeShaderDesc);
    var ShapesShader := TShader.Create(ShapesShaderDesc);

  Vertex attribute locations for vertex shader 'vs':

    var PipDesc: TPipelineDesc;
    PipDesc.Init;
    PipDesc.Attrs[ATTR_VS_POS]. ...
    PipDesc.Attrs[ATTR_VS_NORM]. ...
    PipDesc. ...
    var Pip := TPipeline.Create(PipDesc);

  Image bind slots, use as index in TBindings.VSImages[] or .FSImages[]:

    SLOT_TEX = 0;

  Bind slot and Delphi record for uniform block 'ShapeUniforms':

    ShapeUniforms: TShapeUniforms;
    ShapeUniforms.Mvp := ...;
    ShapeUniforms.Model := ...;
    ShapeUniforms.ShapeColor := ...;
    ShapeUniforms.LightDir := ...;
    ShapeUniforms.EyePos := ...;
    TGfx.ApplyUniforms(TShaderStage.[VertexShader|FragmentShader], SLOT_SHAPE_UNIFORMS, TRange.Create(ShapeUniforms));

}

{$INCLUDE 'Neslib.Sokol.inc'}

interface

uses
  Neslib.FastMath,
  Neslib.Sokol.Gfx;

const
  ATTR_VS_POS = 0;
  ATTR_VS_NORM = 1;

const
  SLOT_TEX = 0;

const
  SLOT_SHAPE_UNIFORMS = 0;

type
  TShapeUniforms = packed record
  public
    Mvp: TMatrix4;
    Model: TMatrix4;
    ShapeColor: TVector4;
    LightDir: TVector4;
    EyePos: TVector4;
  end;

function CubeShaderDesc: PNativeShaderDesc;
function ShapesShaderDesc: PNativeShaderDesc;

implementation

uses
  Neslib.Sokol.Api;

{$IFDEF SOKOL_GLCORE33}
const
  VS_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform vec4 shape_uniforms[11];'#10+
    'layout(location = 0) in vec4 pos;'#10+
    'out vec3 world_position;'#10+
    'out vec3 world_normal;'#10+
    'layout(location = 1) in vec3 norm;'#10+
    'out vec3 world_eyepos;'#10+
    'out vec3 world_lightdir;'#10+
    'out vec4 color;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(shape_uniforms[0], shape_uniforms[1], shape_uniforms[2], shape_uniforms[3]) * pos;'#10+
    '    mat4 _36 = mat4(shape_uniforms[4], shape_uniforms[5], shape_uniforms[6], shape_uniforms[7]);'#10+
    '    world_position = (_36 * pos).xyz;'#10+
    '    world_normal = (_36 * vec4(norm, 0.0)).xyz;'#10+
    '    world_eyepos = shape_uniforms[10].xyz;'#10+
    '    world_lightdir = shape_uniforms[9].xyz;'#10+
    '    color = shape_uniforms[8];'#10+
    '}';

const
  FS_SHAPES_SOURCE_GLSL330 =
    '#version 330'#10+

    'in vec3 world_eyepos;'#10+
    'in vec3 world_position;'#10+
    'in vec3 world_normal;'#10+
    'in vec3 world_lightdir;'#10+
    'layout(location = 0) out vec4 frag_color;'#10+
    'in vec4 color;'#10+

    'vec3 light(vec3 base_color, vec3 eye_vec, vec3 normal, vec3 light_vec)'#10+
    '{'#10+
    '    float _26 = max(dot(normal, light_vec), 0.0);'#10+
    '    return (base_color * (_26 + 0.5)) + vec3(pow(max(dot(reflect(-light_vec, normal), eye_vec), 0.0), 16.0) * _26);'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    vec3 param = color.xyz;'#10+
    '    vec3 param_1 = normalize(world_eyepos - world_position);'#10+
    '    vec3 param_2 = normalize(world_normal);'#10+
    '    vec3 param_3 = normalize(world_lightdir);'#10+
    '    frag_color = vec4(light(param, param_1, param_2, param_3), 1.0);'#10+
    '}';

const
  FS_CUBE_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform samplerCube tex;'#10+

    'in vec3 world_eyepos;'#10+
    'in vec3 world_position;'#10+
    'in vec3 world_normal;'#10+
    'in vec3 world_lightdir;'#10+
    'layout(location = 0) out vec4 frag_color;'#10+
    'in vec4 color;'#10+

    'vec3 light(vec3 base_color, vec3 eye_vec, vec3 normal, vec3 light_vec)'#10+
    '{'#10+
    '    float _26 = max(dot(normal, light_vec), 0.0);'#10+
    '    return (base_color * (_26 + 0.5)) + vec3(pow(max(dot(reflect(-light_vec, normal), eye_vec), 0.0), 16.0) * _26);'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    vec3 param = texture(tex, normalize(world_position)).xyz * color.xyz;'#10+
    '    vec3 param_1 = normalize(world_eyepos - world_position);'#10+
    '    vec3 param_2 = normalize(world_normal);'#10+
    '    vec3 param_3 = normalize(world_lightdir);'#10+
    '    frag_color = vec4(light(param, param_1, param_2, param_3), 1.0);'#10+
    '}';

{$ENDIF !SOKOL_GLCORE33}

{$IFDEF SOKOL_GLES2}
const
  VS_SOURCE_GLSL100 =
    '#version 100'#10+

    'uniform vec4 shape_uniforms[11];'#10+
    'attribute vec4 pos;'#10+
    'varying vec3 world_position;'#10+
    'varying vec3 world_normal;'#10+
    'attribute vec3 norm;'#10+
    'varying vec3 world_eyepos;'#10+
    'varying vec3 world_lightdir;'#10+
    'varying vec4 color;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(shape_uniforms[0], shape_uniforms[1], shape_uniforms[2], shape_uniforms[3]) * pos;'#10+
    '    mat4 _36 = mat4(shape_uniforms[4], shape_uniforms[5], shape_uniforms[6], shape_uniforms[7]);'#10+
    '    world_position = (_36 * pos).xyz;'#10+
    '    world_normal = (_36 * vec4(norm, 0.0)).xyz;'#10+
    '    world_eyepos = shape_uniforms[10].xyz;'#10+
    '    world_lightdir = shape_uniforms[9].xyz;'#10+
    '    color = shape_uniforms[8];'#10+
    '}';

const
  FS_SHAPES_SOURCE_GLSL100 =
    '#version 100'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'varying highp vec3 world_eyepos;'#10+
    'varying highp vec3 world_position;'#10+
    'varying highp vec3 world_normal;'#10+
    'varying highp vec3 world_lightdir;'#10+
    'varying highp vec4 color;'#10+

    'highp vec3 light(highp vec3 base_color, highp vec3 eye_vec, highp vec3 normal, highp vec3 light_vec)'#10+
    '{'#10+
    '    highp float _26 = max(dot(normal, light_vec), 0.0);'#10+
    '    return (base_color * (_26 + 0.5)) + vec3(pow(max(dot(reflect(-light_vec, normal), eye_vec), 0.0), 16.0) * _26);'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    highp vec3 param = color.xyz;'#10+
    '    highp vec3 param_1 = normalize(world_eyepos - world_position);'#10+
    '    highp vec3 param_2 = normalize(world_normal);'#10+
    '    highp vec3 param_3 = normalize(world_lightdir);'#10+
    '    gl_FragData[0] = vec4(light(param, param_1, param_2, param_3), 1.0);'#10+
    '}';

const
  FS_CUBE_SOURCE_GLSL100 =
    '#version 100'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'uniform highp samplerCube tex;'#10+

    'varying highp vec3 world_eyepos;'#10+
    'varying highp vec3 world_position;'#10+
    'varying highp vec3 world_normal;'#10+
    'varying highp vec3 world_lightdir;'#10+
    'varying highp vec4 color;'#10+

    'highp vec3 light(highp vec3 base_color, highp vec3 eye_vec, highp vec3 normal, highp vec3 light_vec)'#10+
    '{'#10+
    '    highp float _26 = max(dot(normal, light_vec), 0.0);'#10+
    '    return (base_color * (_26 + 0.5)) + vec3(pow(max(dot(reflect(-light_vec, normal), eye_vec), 0.0), 16.0) * _26);'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    highp vec3 param = textureCube(tex, normalize(world_position)).xyz * color.xyz;'#10+
    '    highp vec3 param_1 = normalize(world_eyepos - world_position);'#10+
    '    highp vec3 param_2 = normalize(world_normal);'#10+
    '    highp vec3 param_3 = normalize(world_lightdir);'#10+
    '    gl_FragData[0] = vec4(light(param, param_1, param_2, param_3), 1.0);'#10+
    '}';

{$ENDIF !SOKOL_GLES2}

{$IFDEF SOKOL_GLES3}
const
  VS_SOURCE_GLSL300ES =
    '#version 300 es'#10+

    'uniform vec4 shape_uniforms[11];'#10+
    'layout(location = 0) in vec4 pos;'#10+
    'out vec3 world_position;'#10+
    'out vec3 world_normal;'#10+
    'layout(location = 1) in vec3 norm;'#10+
    'out vec3 world_eyepos;'#10+
    'out vec3 world_lightdir;'#10+
    'out vec4 color;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(shape_uniforms[0], shape_uniforms[1], shape_uniforms[2], shape_uniforms[3]) * pos;'#10+
    '    mat4 _36 = mat4(shape_uniforms[4], shape_uniforms[5], shape_uniforms[6], shape_uniforms[7]);'#10+
    '    world_position = (_36 * pos).xyz;'#10+
    '    world_normal = (_36 * vec4(norm, 0.0)).xyz;'#10+
    '    world_eyepos = shape_uniforms[10].xyz;'#10+
    '    world_lightdir = shape_uniforms[9].xyz;'#10+
    '    color = shape_uniforms[8];'#10+
    '}';

const
  FS_SHAPES_SOURCE_GLSL300ES =
    '#version 300 es'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'in highp vec3 world_eyepos;'#10+
    'in highp vec3 world_position;'#10+
    'in highp vec3 world_normal;'#10+
    'in highp vec3 world_lightdir;'#10+
    'layout(location = 0) out highp vec4 frag_color;'#10+
    'in highp vec4 color;'#10+

    'highp vec3 light(highp vec3 base_color, highp vec3 eye_vec, highp vec3 normal, highp vec3 light_vec)'#10+
    '{'#10+
    '    highp float _26 = max(dot(normal, light_vec), 0.0);'#10+
    '    return (base_color * (_26 + 0.5)) + vec3(pow(max(dot(reflect(-light_vec, normal), eye_vec), 0.0), 16.0) * _26);'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    highp vec3 param = color.xyz;'#10+
    '    highp vec3 param_1 = normalize(world_eyepos - world_position);'#10+
    '    highp vec3 param_2 = normalize(world_normal);'#10+
    '    highp vec3 param_3 = normalize(world_lightdir);'#10+
    '    frag_color = vec4(light(param, param_1, param_2, param_3), 1.0);'#10+
    '}';

const
  FS_CUBE_SOURCE_GLSL300ES =
    '#version 300 es'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'uniform highp samplerCube tex;'#10+

    'in highp vec3 world_eyepos;'#10+
    'in highp vec3 world_position;'#10+
    'in highp vec3 world_normal;'#10+
    'in highp vec3 world_lightdir;'#10+
    'layout(location = 0) out highp vec4 frag_color;'#10+
    'in highp vec4 color;'#10+

    'highp vec3 light(highp vec3 base_color, highp vec3 eye_vec, highp vec3 normal, highp vec3 light_vec)'#10+
    '{'#10+
    '    highp float _26 = max(dot(normal, light_vec), 0.0);'#10+
    '    return (base_color * (_26 + 0.5)) + vec3(pow(max(dot(reflect(-light_vec, normal), eye_vec), 0.0), 16.0) * _26);'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    highp vec3 param = texture(tex, normalize(world_position)).xyz * color.xyz;'#10+
    '    highp vec3 param_1 = normalize(world_eyepos - world_position);'#10+
    '    highp vec3 param_2 = normalize(world_normal);'#10+
    '    highp vec3 param_3 = normalize(world_lightdir);'#10+
    '    frag_color = vec4(light(param, param_1, param_2, param_3), 1.0);'#10+
    '}';

{$ENDIF !SOKOL_GLES3}

{$IFDEF SOKOL_D3D11}
const
  VS_SOURCE_HLSL5 =
    'cbuffer shape_uniforms : register(b0)'#10+
    '{'#10+
    '    row_major float4x4 _21_mvp : packoffset(c0);'#10+
    '    row_major float4x4 _21_model : packoffset(c4);'#10+
    '    float4 _21_shape_color : packoffset(c8);'#10+
    '    float4 _21_light_dir : packoffset(c9);'#10+
    '    float4 _21_eye_pos : packoffset(c10);'#10+
    '};'#10+


    'static float4 gl_Position;'#10+
    'static float4 pos;'#10+
    'static float3 world_position;'#10+
    'static float3 world_normal;'#10+
    'static float3 norm;'#10+
    'static float3 world_eyepos;'#10+
    'static float3 world_lightdir;'#10+
    'static float4 color;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float4 pos : TEXCOORD0;'#10+
    '    float3 norm : TEXCOORD1;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float3 world_position : TEXCOORD0;'#10+
    '    float3 world_normal : TEXCOORD1;'#10+
    '    float3 world_eyepos : TEXCOORD2;'#10+
    '    float3 world_lightdir : TEXCOORD3;'#10+
    '    float4 color : TEXCOORD4;'#10+
    '    float4 gl_Position : SV_Position;'#10+
    '};'#10+

    'void vert_main()'#10+
    '{'#10+
    '    gl_Position = mul(pos, _21_mvp);'#10+
    '    world_position = mul(pos, _21_model).xyz;'#10+
    '    world_normal = mul(float4(norm, 0.0f), _21_model).xyz;'#10+
    '    world_eyepos = _21_eye_pos.xyz;'#10+
    '    world_lightdir = _21_light_dir.xyz;'#10+
    '    color = _21_shape_color;'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    pos = stage_input.pos;'#10+
    '    norm = stage_input.norm;'#10+
    '    vert_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.gl_Position = gl_Position;'#10+
    '    stage_output.world_position = world_position;'#10+
    '    stage_output.world_normal = world_normal;'#10+
    '    stage_output.world_eyepos = world_eyepos;'#10+
    '    stage_output.world_lightdir = world_lightdir;'#10+
    '    stage_output.color = color;'#10+
    '    return stage_output;'#10+
    '}';

const
  FS_SHAPES_SOURCE_HLSL5 =
    'static float3 world_eyepos;'#10+
    'static float3 world_position;'#10+
    'static float3 world_normal;'#10+
    'static float3 world_lightdir;'#10+
    'static float4 frag_color;'#10+
    'static float4 color;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float3 world_position : TEXCOORD0;'#10+
    '    float3 world_normal : TEXCOORD1;'#10+
    '    float3 world_eyepos : TEXCOORD2;'#10+
    '    float3 world_lightdir : TEXCOORD3;'#10+
    '    float4 color : TEXCOORD4;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 frag_color : SV_Target0;'#10+
    '};'#10+

    'float3 light(float3 base_color, float3 eye_vec, float3 normal, float3 light_vec)'#10+
    '{'#10+
    '    float _26 = max(dot(normal, light_vec), 0.0f);'#10+
    '    return (base_color * (_26 + 0.5f)) + (pow(max(dot(reflect(-light_vec, normal), eye_vec), 0.0f), 16.0f) * _26).xxx;'#10+
    '}'#10+

    'void frag_main()'#10+
    '{'#10+
    '    float3 param = color.xyz;'#10+
    '    float3 param_1 = normalize(world_eyepos - world_position);'#10+
    '    float3 param_2 = normalize(world_normal);'#10+
    '    float3 param_3 = normalize(world_lightdir);'#10+
    '    frag_color = float4(light(param, param_1, param_2, param_3), 1.0f);'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    world_eyepos = stage_input.world_eyepos;'#10+
    '    world_position = stage_input.world_position;'#10+
    '    world_normal = stage_input.world_normal;'#10+
    '    world_lightdir = stage_input.world_lightdir;'#10+
    '    color = stage_input.color;'#10+
    '    frag_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.frag_color = frag_color;'#10+
    '    return stage_output;'#10+
    '}';

const
  FS_CUBE_SOURCE_HLSL5 =
    'TextureCube<float4> tex : register(t0);'#10+
    'SamplerState _tex_sampler : register(s0);'#10+

    'static float3 world_eyepos;'#10+
    'static float3 world_position;'#10+
    'static float3 world_normal;'#10+
    'static float3 world_lightdir;'#10+
    'static float4 frag_color;'#10+
    'static float4 color;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float3 world_position : TEXCOORD0;'#10+
    '    float3 world_normal : TEXCOORD1;'#10+
    '    float3 world_eyepos : TEXCOORD2;'#10+
    '    float3 world_lightdir : TEXCOORD3;'#10+
    '    float4 color : TEXCOORD4;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 frag_color : SV_Target0;'#10+
    '};'#10+

    'float3 light(float3 base_color, float3 eye_vec, float3 normal, float3 light_vec)'#10+
    '{'#10+
    '    float _26 = max(dot(normal, light_vec), 0.0f);'#10+
    '    return (base_color * (_26 + 0.5f)) + (pow(max(dot(reflect(-light_vec, normal), eye_vec), 0.0f), 16.0f) * _26).xxx;'#10+
    '}'#10+

    'void frag_main()'#10+
    '{'#10+
    '    float3 param = tex.Sample(_tex_sampler, normalize(world_position)).xyz * color.xyz;'#10+
    '    float3 param_1 = normalize(world_eyepos - world_position);'#10+
    '    float3 param_2 = normalize(world_normal);'#10+
    '    float3 param_3 = normalize(world_lightdir);'#10+
    '    frag_color = float4(light(param, param_1, param_2, param_3), 1.0f);'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    world_eyepos = stage_input.world_eyepos;'#10+
    '    world_position = stage_input.world_position;'#10+
    '    world_normal = stage_input.world_normal;'#10+
    '    world_lightdir = stage_input.world_lightdir;'#10+
    '    color = stage_input.color;'#10+
    '    frag_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.frag_color = frag_color;'#10+
    '    return stage_output;'#10+
    '}';

{$ENDIF !SOKOL_D3D11}

{$IFDEF SOKOL_METAL}
const
  VS_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct shape_uniforms'#10+
    '{'#10+
    '    float4x4 mvp;'#10+
    '    float4x4 model;'#10+
    '    float4 shape_color;'#10+
    '    float4 light_dir;'#10+
    '    float4 eye_pos;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float3 world_position [[user(locn0)]];'#10+
    '    float3 world_normal [[user(locn1)]];'#10+
    '    float3 world_eyepos [[user(locn2)]];'#10+
    '    float3 world_lightdir [[user(locn3)]];'#10+
    '    float4 color [[user(locn4)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 pos [[attribute(0)]];'#10+
    '    float3 norm [[attribute(1)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant shape_uniforms& _21 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = _21.mvp * in.pos;'#10+
    '    out.world_position = (_21.model * in.pos).xyz;'#10+
    '    out.world_normal = (_21.model * float4(in.norm, 0.0)).xyz;'#10+
    '    out.world_eyepos = _21.eye_pos.xyz;'#10+
    '    out.world_lightdir = _21.light_dir.xyz;'#10+
    '    out.color = _21.shape_color;'#10+
    '    return out;'#10+
    '}';

const
  FS_SHAPES_SOURCE_METAL_MACOS =
    '#pragma clang diagnostic ignored "-Wmissing-prototypes"'#10+

    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float3 world_position [[user(locn0)]];'#10+
    '    float3 world_normal [[user(locn1)]];'#10+
    '    float3 world_eyepos [[user(locn2)]];'#10+
    '    float3 world_lightdir [[user(locn3)]];'#10+
    '    float4 color [[user(locn4)]];'#10+
    '};'#10+

    'static inline __attribute__((always_inline))'#10+
    'float3 light(thread const float3& base_color, thread const float3& eye_vec, thread const float3& normal, thread const float3& light_vec)'#10+
    '{'#10+
    '    float _26 = fast::max(dot(normal, light_vec), 0.0);'#10+
    '    return (base_color * (_26 + 0.5)) + float3(pow(fast::max(dot(reflect(-light_vec, normal), eye_vec), 0.0), 16.0) * _26);'#10+
    '}'#10+

    'fragment main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    float3 param = in.color.xyz;'#10+
    '    float3 param_1 = fast::normalize(in.world_eyepos - in.world_position);'#10+
    '    float3 param_2 = fast::normalize(in.world_normal);'#10+
    '    float3 param_3 = fast::normalize(in.world_lightdir);'#10+
    '    out.frag_color = float4(light(param, param_1, param_2, param_3), 1.0);'#10+
    '    return out;'#10+
    '}';

const
  FS_CUBE_SOURCE_METAL_MACOS =
    '#pragma clang diagnostic ignored "-Wmissing-prototypes"'#10+

    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float3 world_position [[user(locn0)]];'#10+
    '    float3 world_normal [[user(locn1)]];'#10+
    '    float3 world_eyepos [[user(locn2)]];'#10+
    '    float3 world_lightdir [[user(locn3)]];'#10+
    '    float4 color [[user(locn4)]];'#10+
    '};'#10+

    'static inline __attribute__((always_inline))'#10+
    'float3 light(thread const float3& base_color, thread const float3& eye_vec, thread const float3& normal, thread const float3& light_vec)'#10+
    '{'#10+
    '    float _26 = fast::max(dot(normal, light_vec), 0.0);'#10+
    '    return (base_color * (_26 + 0.5)) + float3(pow(fast::max(dot(reflect(-light_vec, normal), eye_vec), 0.0), 16.0) * _26);'#10+
    '}'#10+

    'fragment main0_out main0(main0_in in [[stage_in]], texturecube<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    float3 param = tex.sample(texSmplr, fast::normalize(in.world_position)).xyz * in.color.xyz;'#10+
    '    float3 param_1 = fast::normalize(in.world_eyepos - in.world_position);'#10+
    '    float3 param_2 = fast::normalize(in.world_normal);'#10+
    '    float3 param_3 = fast::normalize(in.world_lightdir);'#10+
    '    out.frag_color = float4(light(param, param_1, param_2, param_3), 1.0);'#10+
    '    return out;'#10+
    '}';

{$ENDIF !SOKOL_METAL}

{$IFDEF SOKOL_METAL}
const
  VS_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct shape_uniforms'#10+
    '{'#10+
    '    float4x4 mvp;'#10+
    '    float4x4 model;'#10+
    '    float4 shape_color;'#10+
    '    float4 light_dir;'#10+
    '    float4 eye_pos;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float3 world_position [[user(locn0)]];'#10+
    '    float3 world_normal [[user(locn1)]];'#10+
    '    float3 world_eyepos [[user(locn2)]];'#10+
    '    float3 world_lightdir [[user(locn3)]];'#10+
    '    float4 color [[user(locn4)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 pos [[attribute(0)]];'#10+
    '    float3 norm [[attribute(1)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant shape_uniforms& _21 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = _21.mvp * in.pos;'#10+
    '    out.world_position = (_21.model * in.pos).xyz;'#10+
    '    out.world_normal = (_21.model * float4(in.norm, 0.0)).xyz;'#10+
    '    out.world_eyepos = _21.eye_pos.xyz;'#10+
    '    out.world_lightdir = _21.light_dir.xyz;'#10+
    '    out.color = _21.shape_color;'#10+
    '    return out;'#10+
    '}';

const
  FS_SHAPES_SOURCE_METAL_IOS =
    '#pragma clang diagnostic ignored "-Wmissing-prototypes"'#10+

    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float3 world_position [[user(locn0)]];'#10+
    '    float3 world_normal [[user(locn1)]];'#10+
    '    float3 world_eyepos [[user(locn2)]];'#10+
    '    float3 world_lightdir [[user(locn3)]];'#10+
    '    float4 color [[user(locn4)]];'#10+
    '};'#10+

    'static inline __attribute__((always_inline))'#10+
    'float3 light(thread const float3& base_color, thread const float3& eye_vec, thread const float3& normal, thread const float3& light_vec)'#10+
    '{'#10+
    '    float _26 = fast::max(dot(normal, light_vec), 0.0);'#10+
    '    return (base_color * (_26 + 0.5)) + float3(pow(fast::max(dot(reflect(-light_vec, normal), eye_vec), 0.0), 16.0) * _26);'#10+
    '}'#10+

    'fragment main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    float3 param = in.color.xyz;'#10+
    '    float3 param_1 = fast::normalize(in.world_eyepos - in.world_position);'#10+
    '    float3 param_2 = fast::normalize(in.world_normal);'#10+
    '    float3 param_3 = fast::normalize(in.world_lightdir);'#10+
    '    out.frag_color = float4(light(param, param_1, param_2, param_3), 1.0);'#10+
    '    return out;'#10+
    '}';

const
  FS_CUBE_SOURCE_METAL_IOS =
    '#pragma clang diagnostic ignored "-Wmissing-prototypes"'#10+

    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float3 world_position [[user(locn0)]];'#10+
    '    float3 world_normal [[user(locn1)]];'#10+
    '    float3 world_eyepos [[user(locn2)]];'#10+
    '    float3 world_lightdir [[user(locn3)]];'#10+
    '    float4 color [[user(locn4)]];'#10+
    '};'#10+

    'static inline __attribute__((always_inline))'#10+
    'float3 light(thread const float3& base_color, thread const float3& eye_vec, thread const float3& normal, thread const float3& light_vec)'#10+
    '{'#10+
    '    float _26 = fast::max(dot(normal, light_vec), 0.0);'#10+
    '    return (base_color * (_26 + 0.5)) + float3(pow(fast::max(dot(reflect(-light_vec, normal), eye_vec), 0.0), 16.0) * _26);'#10+
    '}'#10+

    'fragment main0_out main0(main0_in in [[stage_in]], texturecube<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    float3 param = tex.sample(texSmplr, fast::normalize(in.world_position)).xyz * in.color.xyz;'#10+
    '    float3 param_1 = fast::normalize(in.world_eyepos - in.world_position);'#10+
    '    float3 param_2 = fast::normalize(in.world_normal);'#10+
    '    float3 param_3 = fast::normalize(in.world_lightdir);'#10+
    '    out.frag_color = float4(light(param, param_1, param_2, param_3), 1.0);'#10+
    '    return out;'#10+
    '}';

{$ENDIF !SOKOL_METAL}

var
  GCubeShaderDesc: TNativeShaderDesc;

procedure InitCubeShaderDesc;
begin
  GCubeShaderDesc.Init;
  GCubeShaderDesc.Attrs[0].Init('pos', 'TEXCOORD', 0);
  GCubeShaderDesc.Attrs[1].Init('norm', 'TEXCOORD', 1);

  case TGfx.Backend of
    {$IFDEF SOKOL_GLCORE33}
    TBackend.GLCore33:
      begin
        GCubeShaderDesc.VS.Source := VS_SOURCE_GLSL330;
        GCubeShaderDesc.FS.Source := FS_CUBE_SOURCE_GLSL330;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES2}
    TBackend.Gles2:
      begin
        GCubeShaderDesc.VS.Source := VS_SOURCE_GLSL100;
        GCubeShaderDesc.FS.Source := FS_CUBE_SOURCE_GLSL100;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES3}
    TBackend.Gles3:
      begin
        GCubeShaderDesc.VS.Source := VS_SOURCE_GLSL300ES;
        GCubeShaderDesc.FS.Source := FS_CUBE_SOURCE_GLSL300ES;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_D3D11}
    TBackend.D3D11:
      begin
        GCubeShaderDesc.VS.Source := VS_SOURCE_HLSL5;
        GCubeShaderDesc.FS.Source := FS_CUBE_SOURCE_HLSL5;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalMacOS:
      begin
        GCubeShaderDesc.VS.Source := VS_SOURCE_METAL_MACOS;
        GCubeShaderDesc.FS.Source := FS_CUBE_SOURCE_METAL_MACOS;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalIOS:
      begin
        GCubeShaderDesc.VS.Source := VS_SOURCE_METAL_IOS;
        GCubeShaderDesc.FS.Source := FS_CUBE_SOURCE_METAL_IOS;
      end;
    {$ENDIF}
  else
    Assert(False)
  end;

  GCubeShaderDesc.vs.uniform_blocks[0].size := 176;
  GCubeShaderDesc.vs.uniform_blocks[0].layout := _SG_UNIFORMLAYOUT_STD140;
  if (TGfx.Backend.IsGL) then
    GCubeShaderDesc.vs.uniform_blocks[0].uniforms[0].Init('shape_uniforms', _SG_UNIFORMTYPE_FLOAT4, 11);
  GCubeShaderDesc.fs.images[0].Init('tex', _SG_IMAGETYPE_CUBE, _SG_SAMPLERTYPE_FLOAT);
  GCubeShaderDesc.&label := 'CubeShader';
end;

function CubeShaderDesc: PNativeShaderDesc;
begin
  if (GCubeShaderDesc.VS.Entry = nil) then
    InitCubeShaderDesc;

  Result := @GCubeShaderDesc;
end;


var
  GShapesShaderDesc: TNativeShaderDesc;

procedure InitShapesShaderDesc;
begin
  GShapesShaderDesc.Init;
  GShapesShaderDesc.Attrs[0].Init('pos', 'TEXCOORD', 0);
  GShapesShaderDesc.Attrs[1].Init('norm', 'TEXCOORD', 1);

  case TGfx.Backend of
    {$IFDEF SOKOL_GLCORE33}
    TBackend.GLCore33:
      begin
        GShapesShaderDesc.VS.Source := VS_SOURCE_GLSL330;
        GShapesShaderDesc.FS.Source := FS_SHAPES_SOURCE_GLSL330;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES2}
    TBackend.Gles2:
      begin
        GShapesShaderDesc.VS.Source := VS_SOURCE_GLSL100;
        GShapesShaderDesc.FS.Source := FS_SHAPES_SOURCE_GLSL100;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES3}
    TBackend.Gles3:
      begin
        GShapesShaderDesc.VS.Source := VS_SOURCE_GLSL300ES;
        GShapesShaderDesc.FS.Source := FS_SHAPES_SOURCE_GLSL300ES;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_D3D11}
    TBackend.D3D11:
      begin
        GShapesShaderDesc.VS.Source := VS_SOURCE_HLSL5;
        GShapesShaderDesc.FS.Source := FS_SHAPES_SOURCE_HLSL5;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalMacOS:
      begin
        GShapesShaderDesc.VS.Source := VS_SOURCE_METAL_MACOS;
        GShapesShaderDesc.FS.Source := FS_SHAPES_SOURCE_METAL_MACOS;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalIOS:
      begin
        GShapesShaderDesc.VS.Source := VS_SOURCE_METAL_IOS;
        GShapesShaderDesc.FS.Source := FS_SHAPES_SOURCE_METAL_IOS;
      end;
    {$ENDIF}
  else
    Assert(False)
  end;

  GShapesShaderDesc.vs.uniform_blocks[0].size := 176;
  GShapesShaderDesc.vs.uniform_blocks[0].layout := _SG_UNIFORMLAYOUT_STD140;
  if (TGfx.Backend.IsGL) then
    GShapesShaderDesc.vs.uniform_blocks[0].uniforms[0].Init('shape_uniforms', _SG_UNIFORMTYPE_FLOAT4, 11);
  GShapesShaderDesc.&label := 'ShapesShader';
end;

function ShapesShaderDesc: PNativeShaderDesc;
begin
  if (GShapesShaderDesc.VS.Entry = nil) then
    InitShapesShaderDesc;

  Result := @GShapesShaderDesc;
end;

end.
