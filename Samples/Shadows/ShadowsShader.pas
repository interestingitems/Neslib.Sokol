unit ShadowsShader;
{ #version:1# (machine generated, don't edit!)

  Generated by sokol-shdc (https://github.com/floooh/sokol-tools)
  With Delphi modifications (https://github.com/neslib/Neslib.Sokol.Tools)

  Cmdline: sokol-shdc --input ShadowsShader.glsl --output ShadowsShader.pas

  Overview:

    Shader program 'color':
      Get shader desc: ColorShaderDesc()
      Vertex shader: colorVS
        Attribute slots:
          ATTR_COLORVS_POSITION = 0
          ATTR_COLORVS_NORMAL = 1
        Uniform block 'vs_light_params':
          Delphi record: TVSLightParams
          Bind slot: SLOT_VS_LIGHT_PARAMS = 0
      Fragment shader: colorFS
        Uniform block 'fs_light_params':
          Delphi record: TFSLightParams
          Bind slot: SLOT_FS_LIGHT_PARAMS = 0
        Image 'shadowMap':
          Type: _SG_IMAGETYPE_2D
          Component Type: _SG_SAMPLERTYPE_FLOAT
          Bind slot: SLOT_SHADOWMAP = 0

    Shader program 'shadow':
      Get shader desc: ShadowShaderDesc()
      Vertex shader: shadowVS
        Attribute slots:
          ATTR_SHADOWVS_POSITION = 0
        Uniform block 'vs_shadow_params':
          Delphi record: TVSShadowParams
          Bind slot: SLOT_VS_SHADOW_PARAMS = 0
      Fragment shader: shadowFS


  Shader descriptor records:

    var ColorShader := TShader.Create(ColorShaderDesc);
    var ShadowShader := TShader.Create(ShadowShaderDesc);

  Vertex attribute locations for vertex shader 'shadowVS':

    var PipDesc: TPipelineDesc;
    PipDesc.Init;
    PipDesc.Attrs[ATTR_SHADOWVS_POSITION]. ...
    PipDesc. ...
    var Pip := TPipeline.Create(PipDesc);

  Vertex attribute locations for vertex shader 'colorVS':

    var PipDesc: TPipelineDesc;
    PipDesc.Init;
    PipDesc.Attrs[ATTR_COLORVS_POSITION]. ...
    PipDesc.Attrs[ATTR_COLORVS_NORMAL]. ...
    PipDesc. ...
    var Pip := TPipeline.Create(PipDesc);

  Image bind slots, use as index in TBindings.VSImages[] or .FSImages[]:

    SLOT_SHADOWMAP = 0;

  Bind slot and Delphi record for uniform block 'VSShadowParams':

    VSShadowParams: TVSShadowParams;
    VSShadowParams.Mvp := ...;
    TGfx.ApplyUniforms(TShaderStage.[VertexShader|FragmentShader], SLOT_VS_SHADOW_PARAMS, TRange.Create(VSShadowParams));

  Bind slot and Delphi record for uniform block 'VSLightParams':

    VSLightParams: TVSLightParams;
    VSLightParams.Model := ...;
    VSLightParams.Mvp := ...;
    VSLightParams.LightMVP := ...;
    VSLightParams.DiffColor := ...;
    TGfx.ApplyUniforms(TShaderStage.[VertexShader|FragmentShader], SLOT_VS_LIGHT_PARAMS, TRange.Create(VSLightParams));

  Bind slot and Delphi record for uniform block 'FSLightParams':

    FSLightParams: TFSLightParams;
    FSLightParams.ShadowMapSize := ...;
    FSLightParams.LightDir := ...;
    FSLightParams.EyePos := ...;
    TGfx.ApplyUniforms(TShaderStage.[VertexShader|FragmentShader], SLOT_FS_LIGHT_PARAMS, TRange.Create(FSLightParams));

}

{$INCLUDE 'Neslib.Sokol.inc'}

interface

uses
  Neslib.FastMath,
  Neslib.Sokol.Gfx;

const
  ATTR_SHADOWVS_POSITION = 0;
  ATTR_COLORVS_POSITION = 0;
  ATTR_COLORVS_NORMAL = 1;

const
  SLOT_SHADOWMAP = 0;

const
  SLOT_VS_SHADOW_PARAMS = 0;

type
  TVSShadowParams = packed record
  public
    Mvp: TMatrix4;
  end;

const
  SLOT_VS_LIGHT_PARAMS = 0;

type
  TVSLightParams = packed record
  public
    Model: TMatrix4;
    Mvp: TMatrix4;
    LightMVP: TMatrix4;
    DiffColor: TVector3;
    _Pad204: array [0..3] of UInt8;
  end;

const
  SLOT_FS_LIGHT_PARAMS = 0;

type
  TFSLightParams = packed record
  public
    ShadowMapSize: TVector2;
    _Pad8: array [0..7] of UInt8;
    LightDir: TVector3;
    _Pad28: array [0..3] of UInt8;
    EyePos: TVector3;
    _Pad44: array [0..3] of UInt8;
  end;

function ColorShaderDesc: PNativeShaderDesc;
function ShadowShaderDesc: PNativeShaderDesc;

implementation

uses
  Neslib.Sokol.Api;

{$IFDEF SOKOL_GLCORE33}
const
  SHADOWVS_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform vec4 vs_shadow_params[4];'#10+
    'layout(location = 0) in vec4 position;'#10+
    'out vec2 projZW;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(vs_shadow_params[0], vs_shadow_params[1], vs_shadow_params[2], vs_shadow_params[3]) * position;'#10+
    '    projZW = gl_Position.zw;'#10+
    '}';

const
  SHADOWFS_SOURCE_GLSL330 =
    '#version 330'#10+

    'in vec2 projZW;'#10+
    'layout(location = 0) out vec4 fragColor;'#10+

    'vec4 encodeDepth(float v)'#10+
    '{'#10+
    '    vec4 _25 = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);'#10+
    '    return _25 - (_25.yzww * vec4(0.0039215688593685626983642578125, 0.0039215688593685626983642578125, 0.0039215688593685626983642578125, 0.0));'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    float param = projZW.x / projZW.y;'#10+
    '    fragColor = encodeDepth(param);'#10+
    '}';

const
  COLORVS_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform vec4 vs_light_params[13];'#10+
    'layout(location = 0) in vec4 position;'#10+
    'out vec4 lightProjPos;'#10+
    'out vec4 P;'#10+
    'out vec3 N;'#10+
    'layout(location = 1) in vec3 normal;'#10+
    'out vec3 color;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(vs_light_params[4], vs_light_params[5], vs_light_params[6], vs_light_params[7]) * position;'#10+
    '    lightProjPos = mat4(vs_light_params[8], vs_light_params[9], vs_light_params[10], vs_light_params[11]) * position;'#10+
    '    mat4 _41 = mat4(vs_light_params[0], vs_light_params[1], vs_light_params[2], vs_light_params[3]);'#10+
    '    P = _41 * position;'#10+
    '    N = (_41 * vec4(normal, 0.0)).xyz;'#10+
    '    color = vs_light_params[12].xyz;'#10+
    '}';

const
  COLORFS_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform vec4 fs_light_params[3];'#10+
    'uniform sampler2D shadowMap;'#10+

    'in vec3 N;'#10+
    'in vec4 lightProjPos;'#10+
    'in vec4 P;'#10+
    'layout(location = 0) out vec4 fragColor;'#10+
    'in vec3 color;'#10+

    'float decodeDepth(vec4 rgba)'#10+
    '{'#10+
    '    return dot(rgba, vec4(1.0, 0.0039215688593685626983642578125, 1.5378700481960549950599670410156e-05, 6.0308629201699659461155533790588e-08));'#10+
    '}'#10+

    'float sampleShadow(sampler2D shadowMap_1, vec2 uv, float compare)'#10+
    '{'#10+
    '    vec4 param = texture(shadowMap_1, vec2(uv.x, uv.y));'#10+
    '    return step(compare, decodeDepth(param) + 0.001000000047497451305389404296875);'#10+
    '}'#10+

    'float sampleShadowPCF(sampler2D shadowMap_1, vec2 uv, vec2 smSize, float compare)'#10+
    '{'#10+
    '    float result = 0.0;'#10+
    '    for (int x = -2; x <= 2; x++)'#10+
    '    {'#10+
    '        for (int y = -2; y <= 2; y++)'#10+
    '        {'#10+
    '            vec2 param = uv + (vec2(float(x), float(y)) / smSize);'#10+
    '            float param_1 = compare;'#10+
    '            result += sampleShadow(shadowMap_1, param, param_1);'#10+
    '        }'#10+
    '    }'#10+
    '    return result * 0.039999999105930328369140625;'#10+
    '}'#10+

    'vec4 gamma(vec4 c)'#10+
    '{'#10+
    '    return vec4(pow(c.xyz, vec3(0.4545454680919647216796875)), c.w);'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    vec3 _149 = normalize(fs_light_params[1].xyz);'#10+
    '    vec3 _154 = normalize(N);'#10+
    '    float _158 = dot(_154, _149);'#10+
    '    if (_158 > 0.0)'#10+
    '    {'#10+
    '        vec3 _172 = lightProjPos.xyz / vec3(lightProjPos.w);'#10+
    '        vec2 param = (_172.xy + vec2(1.0)) * 0.5;'#10+
    '        vec2 param_1 = fs_light_params[0].xy;'#10+
    '        float param_2 = _172.z;'#10+
    '        float _195 = sampleShadowPCF(shadowMap, param, param_1, param_2);'#10+
    '        fragColor = vec4(vec3((pow(max(dot(reflect(-_149, _154), normalize(fs_light_params[2].xyz - P.xyz)), 0.0), 2.2000000476837158203125) * _158) * _195) + (color * (max(_158 * _195, 0.0) + '+
      '0.25)), 1.0);'#10+
    '    }'#10+
    '    else'#10+
    '    {'#10+
    '        fragColor = vec4(color * 0.25, 1.0);'#10+
    '    }'#10+
    '    vec4 param_3 = fragColor;'#10+
    '    fragColor = gamma(param_3);'#10+
    '}';

{$ENDIF !SOKOL_GLCORE33}

{$IFDEF SOKOL_GLES2}
const
  SHADOWVS_SOURCE_GLSL100 =
    '#version 100'#10+

    'uniform vec4 vs_shadow_params[4];'#10+
    'attribute vec4 position;'#10+
    'varying vec2 projZW;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(vs_shadow_params[0], vs_shadow_params[1], vs_shadow_params[2], vs_shadow_params[3]) * position;'#10+
    '    projZW = gl_Position.zw;'#10+
    '}';

const
  SHADOWFS_SOURCE_GLSL100 =
    '#version 100'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'varying highp vec2 projZW;'#10+

    'highp vec4 encodeDepth(highp float v)'#10+
    '{'#10+
    '    highp vec4 _25 = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);'#10+
    '    return _25 - (_25.yzww * vec4(0.0039215688593685626983642578125, 0.0039215688593685626983642578125, 0.0039215688593685626983642578125, 0.0));'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    highp float param = projZW.x / projZW.y;'#10+
    '    gl_FragData[0] = encodeDepth(param);'#10+
    '}';

const
  COLORVS_SOURCE_GLSL100 =
    '#version 100'#10+

    'uniform vec4 vs_light_params[13];'#10+
    'attribute vec4 position;'#10+
    'varying vec4 lightProjPos;'#10+
    'varying vec4 P;'#10+
    'varying vec3 N;'#10+
    'attribute vec3 normal;'#10+
    'varying vec3 color;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(vs_light_params[4], vs_light_params[5], vs_light_params[6], vs_light_params[7]) * position;'#10+
    '    lightProjPos = mat4(vs_light_params[8], vs_light_params[9], vs_light_params[10], vs_light_params[11]) * position;'#10+
    '    mat4 _41 = mat4(vs_light_params[0], vs_light_params[1], vs_light_params[2], vs_light_params[3]);'#10+
    '    P = _41 * position;'#10+
    '    N = (_41 * vec4(normal, 0.0)).xyz;'#10+
    '    color = vs_light_params[12].xyz;'#10+
    '}';

const
  COLORFS_SOURCE_GLSL100 =
    '#version 100'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'uniform highp vec4 fs_light_params[3];'#10+
    'uniform highp sampler2D shadowMap;'#10+

    'varying highp vec3 N;'#10+
    'varying highp vec4 lightProjPos;'#10+
    'varying highp vec4 P;'#10+
    'varying highp vec3 color;'#10+

    'highp float decodeDepth(highp vec4 rgba)'#10+
    '{'#10+
    '    return dot(rgba, vec4(1.0, 0.0039215688593685626983642578125, 1.5378700481960549950599670410156e-05, 6.0308629201699659461155533790588e-08));'#10+
    '}'#10+

    'highp float sampleShadow(highp sampler2D shadowMap_1, highp vec2 uv, highp float compare)'#10+
    '{'#10+
    '    highp vec4 param = texture2D(shadowMap_1, vec2(uv.x, uv.y));'#10+
    '    return step(compare, decodeDepth(param) + 0.001000000047497451305389404296875);'#10+
    '}'#10+

    'highp float sampleShadowPCF(highp sampler2D shadowMap_1, highp vec2 uv, highp vec2 smSize, highp float compare)'#10+
    '{'#10+
    '    highp float result = 0.0;'#10+
    '    for (int x = -2; x <= 2; x++)'#10+
    '    {'#10+
    '        for (int y = -2; y <= 2; y++)'#10+
    '        {'#10+
    '            highp vec2 param = uv + (vec2(float(x), float(y)) / smSize);'#10+
    '            highp float param_1 = compare;'#10+
    '            result += sampleShadow(shadowMap_1, param, param_1);'#10+
    '        }'#10+
    '    }'#10+
    '    return result * 0.039999999105930328369140625;'#10+
    '}'#10+

    'highp vec4 gamma(highp vec4 c)'#10+
    '{'#10+
    '    return vec4(pow(c.xyz, vec3(0.4545454680919647216796875)), c.w);'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    highp vec3 _149 = normalize(fs_light_params[1].xyz);'#10+
    '    highp vec3 _154 = normalize(N);'#10+
    '    highp float _158 = dot(_154, _149);'#10+
    '    if (_158 > 0.0)'#10+
    '    {'#10+
    '        highp vec3 _172 = lightProjPos.xyz / vec3(lightProjPos.w);'#10+
    '        highp vec2 param = (_172.xy + vec2(1.0)) * 0.5;'#10+
    '        highp vec2 param_1 = fs_light_params[0].xy;'#10+
    '        highp float param_2 = _172.z;'#10+
    '        highp float _195 = sampleShadowPCF(shadowMap, param, param_1, param_2);'#10+
    '        gl_FragData[0] = vec4(vec3((pow(max(dot(reflect(-_149, _154), normalize(fs_light_params[2].xyz - P.xyz)), 0.0), 2.2000000476837158203125) * _158) * _195) + (color * (max(_158 * _195, 0.0) + '+
      '0.25)), 1.0);'#10+
    '    }'#10+
    '    else'#10+
    '    {'#10+
    '        gl_FragData[0] = vec4(color * 0.25, 1.0);'#10+
    '    }'#10+
    '    highp vec4 param_3 = gl_FragData[0];'#10+
    '    gl_FragData[0] = gamma(param_3);'#10+
    '}';

{$ENDIF !SOKOL_GLES2}

{$IFDEF SOKOL_GLES3}
const
  SHADOWVS_SOURCE_GLSL300ES =
    '#version 300 es'#10+

    'uniform vec4 vs_shadow_params[4];'#10+
    'layout(location = 0) in vec4 position;'#10+
    'out vec2 projZW;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(vs_shadow_params[0], vs_shadow_params[1], vs_shadow_params[2], vs_shadow_params[3]) * position;'#10+
    '    projZW = gl_Position.zw;'#10+
    '}';

const
  SHADOWFS_SOURCE_GLSL300ES =
    '#version 300 es'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'in highp vec2 projZW;'#10+
    'layout(location = 0) out highp vec4 fragColor;'#10+

    'highp vec4 encodeDepth(highp float v)'#10+
    '{'#10+
    '    highp vec4 _25 = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);'#10+
    '    return _25 - (_25.yzww * vec4(0.0039215688593685626983642578125, 0.0039215688593685626983642578125, 0.0039215688593685626983642578125, 0.0));'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    highp float param = projZW.x / projZW.y;'#10+
    '    fragColor = encodeDepth(param);'#10+
    '}';

const
  COLORVS_SOURCE_GLSL300ES =
    '#version 300 es'#10+

    'uniform vec4 vs_light_params[13];'#10+
    'layout(location = 0) in vec4 position;'#10+
    'out vec4 lightProjPos;'#10+
    'out vec4 P;'#10+
    'out vec3 N;'#10+
    'layout(location = 1) in vec3 normal;'#10+
    'out vec3 color;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(vs_light_params[4], vs_light_params[5], vs_light_params[6], vs_light_params[7]) * position;'#10+
    '    lightProjPos = mat4(vs_light_params[8], vs_light_params[9], vs_light_params[10], vs_light_params[11]) * position;'#10+
    '    mat4 _41 = mat4(vs_light_params[0], vs_light_params[1], vs_light_params[2], vs_light_params[3]);'#10+
    '    P = _41 * position;'#10+
    '    N = (_41 * vec4(normal, 0.0)).xyz;'#10+
    '    color = vs_light_params[12].xyz;'#10+
    '}';

const
  COLORFS_SOURCE_GLSL300ES =
    '#version 300 es'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'uniform highp vec4 fs_light_params[3];'#10+
    'uniform highp sampler2D shadowMap;'#10+

    'in highp vec3 N;'#10+
    'in highp vec4 lightProjPos;'#10+
    'in highp vec4 P;'#10+
    'layout(location = 0) out highp vec4 fragColor;'#10+
    'in highp vec3 color;'#10+

    'highp float decodeDepth(highp vec4 rgba)'#10+
    '{'#10+
    '    return dot(rgba, vec4(1.0, 0.0039215688593685626983642578125, 1.5378700481960549950599670410156e-05, 6.0308629201699659461155533790588e-08));'#10+
    '}'#10+

    'highp float sampleShadow(highp sampler2D shadowMap_1, highp vec2 uv, highp float compare)'#10+
    '{'#10+
    '    highp vec4 param = texture(shadowMap_1, vec2(uv.x, uv.y));'#10+
    '    return step(compare, decodeDepth(param) + 0.001000000047497451305389404296875);'#10+
    '}'#10+

    'highp float sampleShadowPCF(highp sampler2D shadowMap_1, highp vec2 uv, highp vec2 smSize, highp float compare)'#10+
    '{'#10+
    '    highp float result = 0.0;'#10+
    '    for (int x = -2; x <= 2; x++)'#10+
    '    {'#10+
    '        for (int y = -2; y <= 2; y++)'#10+
    '        {'#10+
    '            highp vec2 param = uv + (vec2(float(x), float(y)) / smSize);'#10+
    '            highp float param_1 = compare;'#10+
    '            result += sampleShadow(shadowMap_1, param, param_1);'#10+
    '        }'#10+
    '    }'#10+
    '    return result * 0.039999999105930328369140625;'#10+
    '}'#10+

    'highp vec4 gamma(highp vec4 c)'#10+
    '{'#10+
    '    return vec4(pow(c.xyz, vec3(0.4545454680919647216796875)), c.w);'#10+
    '}'#10+

    'void main()'#10+
    '{'#10+
    '    highp vec3 _149 = normalize(fs_light_params[1].xyz);'#10+
    '    highp vec3 _154 = normalize(N);'#10+
    '    highp float _158 = dot(_154, _149);'#10+
    '    if (_158 > 0.0)'#10+
    '    {'#10+
    '        highp vec3 _172 = lightProjPos.xyz / vec3(lightProjPos.w);'#10+
    '        highp vec2 param = (_172.xy + vec2(1.0)) * 0.5;'#10+
    '        highp vec2 param_1 = fs_light_params[0].xy;'#10+
    '        highp float param_2 = _172.z;'#10+
    '        highp float _195 = sampleShadowPCF(shadowMap, param, param_1, param_2);'#10+
    '        fragColor = vec4(vec3((pow(max(dot(reflect(-_149, _154), normalize(fs_light_params[2].xyz - P.xyz)), 0.0), 2.2000000476837158203125) * _158) * _195) + (color * (max(_158 * _195, 0.0) + '+
      '0.25)), 1.0);'#10+
    '    }'#10+
    '    else'#10+
    '    {'#10+
    '        fragColor = vec4(color * 0.25, 1.0);'#10+
    '    }'#10+
    '    highp vec4 param_3 = fragColor;'#10+
    '    fragColor = gamma(param_3);'#10+
    '}';

{$ENDIF !SOKOL_GLES3}

{$IFDEF SOKOL_D3D11}
const
  SHADOWVS_SOURCE_HLSL5 =
    'cbuffer vs_shadow_params : register(b0)'#10+
    '{'#10+
    '    row_major float4x4 _21_mvp : packoffset(c0);'#10+
    '};'#10+


    'static float4 gl_Position;'#10+
    'static float4 position;'#10+
    'static float2 projZW;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float4 position : TEXCOORD0;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float2 projZW : TEXCOORD0;'#10+
    '    float4 gl_Position : SV_Position;'#10+
    '};'#10+

    'void vert_main()'#10+
    '{'#10+
    '    gl_Position = mul(position, _21_mvp);'#10+
    '    projZW = gl_Position.zw;'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    position = stage_input.position;'#10+
    '    vert_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.gl_Position = gl_Position;'#10+
    '    stage_output.projZW = projZW;'#10+
    '    return stage_output;'#10+
    '}';

const
  SHADOWFS_SOURCE_HLSL5 =
    'static float2 projZW;'#10+
    'static float4 fragColor;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float2 projZW : TEXCOORD0;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 fragColor : SV_Target0;'#10+
    '};'#10+

    'float4 encodeDepth(float v)'#10+
    '{'#10+
    '    float4 _25 = frac(float4(1.0f, 255.0f, 65025.0f, 16581375.0f) * v);'#10+
    '    return _25 - (_25.yzww * float4(0.0039215688593685626983642578125f, 0.0039215688593685626983642578125f, 0.0039215688593685626983642578125f, 0.0f));'#10+
    '}'#10+

    'void frag_main()'#10+
    '{'#10+
    '    float param = projZW.x / projZW.y;'#10+
    '    fragColor = encodeDepth(param);'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    projZW = stage_input.projZW;'#10+
    '    frag_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.fragColor = fragColor;'#10+
    '    return stage_output;'#10+
    '}';

const
  COLORVS_SOURCE_HLSL5 =
    'cbuffer vs_light_params : register(b0)'#10+
    '{'#10+
    '    row_major float4x4 _22_model : packoffset(c0);'#10+
    '    row_major float4x4 _22_mvp : packoffset(c4);'#10+
    '    row_major float4x4 _22_lightMVP : packoffset(c8);'#10+
    '    float3 _22_diffColor : packoffset(c12);'#10+
    '};'#10+


    'static float4 gl_Position;'#10+
    'static float4 position;'#10+
    'static float4 lightProjPos;'#10+
    'static float4 P;'#10+
    'static float3 N;'#10+
    'static float3 normal;'#10+
    'static float3 color;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float4 position : TEXCOORD0;'#10+
    '    float3 normal : TEXCOORD1;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float3 color : TEXCOORD0;'#10+
    '    float4 lightProjPos : TEXCOORD1;'#10+
    '    float4 P : TEXCOORD2;'#10+
    '    float3 N : TEXCOORD3;'#10+
    '    float4 gl_Position : SV_Position;'#10+
    '};'#10+

    'void vert_main()'#10+
    '{'#10+
    '    gl_Position = mul(position, _22_mvp);'#10+
    '    lightProjPos = mul(position, _22_lightMVP);'#10+
    '    P = mul(position, _22_model);'#10+
    '    N = mul(float4(normal, 0.0f), _22_model).xyz;'#10+
    '    color = _22_diffColor;'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    position = stage_input.position;'#10+
    '    normal = stage_input.normal;'#10+
    '    vert_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.gl_Position = gl_Position;'#10+
    '    stage_output.lightProjPos = lightProjPos;'#10+
    '    stage_output.P = P;'#10+
    '    stage_output.N = N;'#10+
    '    stage_output.color = color;'#10+
    '    return stage_output;'#10+
    '}';

const
  COLORFS_SOURCE_HLSL5 =
    'cbuffer fs_light_params : register(b0)'#10+
    '{'#10+
    '    float2 _149_shadowMapSize : packoffset(c0);'#10+
    '    float3 _149_lightDir : packoffset(c1);'#10+
    '    float3 _149_eyePos : packoffset(c2);'#10+
    '};'#10+

    'Texture2D<float4> shadowMap : register(t0);'#10+
    'SamplerState _shadowMap_sampler : register(s0);'#10+

    'static float3 N;'#10+
    'static float4 lightProjPos;'#10+
    'static float4 P;'#10+
    'static float4 fragColor;'#10+
    'static float3 color;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float3 color : TEXCOORD0;'#10+
    '    float4 lightProjPos : TEXCOORD1;'#10+
    '    float4 P : TEXCOORD2;'#10+
    '    float3 N : TEXCOORD3;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 fragColor : SV_Target0;'#10+
    '};'#10+

    'float decodeDepth(float4 rgba)'#10+
    '{'#10+
    '    return dot(rgba, float4(1.0f, 0.0039215688593685626983642578125f, 1.5378700481960549950599670410156e-05f, 6.0308629201699659461155533790588e-08f));'#10+
    '}'#10+

    'float sampleShadow(Texture2D<float4> shadowMap_1, SamplerState _shadowMap_1_sampler, inout float2 uv, float compare)'#10+
    '{'#10+
    '    uv.y = 1.0f - uv.y;'#10+
    '    float4 param = shadowMap_1.Sample(_shadowMap_1_sampler, float2(uv.x, uv.y));'#10+
    '    return step(compare, decodeDepth(param) + 0.001000000047497451305389404296875f);'#10+
    '}'#10+

    'float sampleShadowPCF(Texture2D<float4> shadowMap_1, SamplerState _shadowMap_1_sampler, float2 uv, float2 smSize, float compare)'#10+
    '{'#10+
    '    float result = 0.0f;'#10+
    '    for (int x = -2; x <= 2; x++)'#10+
    '    {'#10+
    '        for (int y = -2; y <= 2; y++)'#10+
    '        {'#10+
    '            float2 param = uv + (float2(float(x), float(y)) / smSize);'#10+
    '            float param_1 = compare;'#10+
    '            float _109 = sampleShadow(shadowMap_1, _shadowMap_1_sampler, param, param_1);'#10+
    '            result += _109;'#10+
    '        }'#10+
    '    }'#10+
    '    return result * 0.039999999105930328369140625f;'#10+
    '}'#10+

    'float4 gamma(float4 c)'#10+
    '{'#10+
    '    return float4(pow(c.xyz, 0.4545454680919647216796875f.xxx), c.w);'#10+
    '}'#10+

    'void frag_main()'#10+
    '{'#10+
    '    float3 _153 = normalize(_149_lightDir);'#10+
    '    float3 _158 = normalize(N);'#10+
    '    float _162 = dot(_158, _153);'#10+
    '    if (_162 > 0.0f)'#10+
    '    {'#10+
    '        float3 _176 = lightProjPos.xyz / lightProjPos.w.xxx;'#10+
    '        float2 param = (_176.xy + 1.0f.xx) * 0.5f;'#10+
    '        float2 param_1 = _149_shadowMapSize;'#10+
    '        float param_2 = _176.z;'#10+
    '        float _199 = sampleShadowPCF(shadowMap, _shadowMap_sampler, param, param_1, param_2);'#10+
    '        fragColor = float4(((pow(max(dot(reflect(-_153, _158), normalize(_149_eyePos - P.xyz)), 0.0f), 2.2000000476837158203125f) * _162) * _199).xxx + (color * (max(_162 * _199, 0.0f) + 0.25f)), '+
      '1.0f);'#10+
    '    }'#10+
    '    else'#10+
    '    {'#10+
    '        fragColor = float4(color * 0.25f, 1.0f);'#10+
    '    }'#10+
    '    float4 param_3 = fragColor;'#10+
    '    fragColor = gamma(param_3);'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    N = stage_input.N;'#10+
    '    lightProjPos = stage_input.lightProjPos;'#10+
    '    P = stage_input.P;'#10+
    '    color = stage_input.color;'#10+
    '    frag_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.fragColor = fragColor;'#10+
    '    return stage_output;'#10+
    '}';

{$ENDIF !SOKOL_D3D11}

{$IFDEF SOKOL_METAL}
const
  SHADOWVS_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct vs_shadow_params'#10+
    '{'#10+
    '    float4x4 mvp;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float2 projZW [[user(locn0)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 position [[attribute(0)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant vs_shadow_params& _21 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = _21.mvp * in.position;'#10+
    '    out.projZW = out.gl_Position.zw;'#10+
    '    return out;'#10+
    '}';

const
  SHADOWFS_SOURCE_METAL_MACOS =
    '#pragma clang diagnostic ignored "-Wmissing-prototypes"'#10+

    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 fragColor [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 projZW [[user(locn0)]];'#10+
    '};'#10+

    'static inline __attribute__((always_inline))'#10+
    'float4 encodeDepth(thread const float& v)'#10+
    '{'#10+
    '    float4 _25 = fract(float4(1.0, 255.0, 65025.0, 16581375.0) * v);'#10+
    '    return _25 - (_25.yzww * float4(0.0039215688593685626983642578125, 0.0039215688593685626983642578125, 0.0039215688593685626983642578125, 0.0));'#10+
    '}'#10+

    'fragment main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    float param = in.projZW.x / in.projZW.y;'#10+
    '    out.fragColor = encodeDepth(param);'#10+
    '    return out;'#10+
    '}';

const
  COLORVS_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct vs_light_params'#10+
    '{'#10+
    '    float4x4 model;'#10+
    '    float4x4 mvp;'#10+
    '    float4x4 lightMVP;'#10+
    '    float3 diffColor;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float3 color [[user(locn0)]];'#10+
    '    float4 lightProjPos [[user(locn1)]];'#10+
    '    float4 P [[user(locn2)]];'#10+
    '    float3 N [[user(locn3)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 position [[attribute(0)]];'#10+
    '    float3 normal [[attribute(1)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant vs_light_params& _22 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = _22.mvp * in.position;'#10+
    '    out.lightProjPos = _22.lightMVP * in.position;'#10+
    '    out.P = _22.model * in.position;'#10+
    '    out.N = (_22.model * float4(in.normal, 0.0)).xyz;'#10+
    '    out.color = _22.diffColor;'#10+
    '    return out;'#10+
    '}';

const
  COLORFS_SOURCE_METAL_MACOS =
    '#pragma clang diagnostic ignored "-Wmissing-prototypes"'#10+

    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct fs_light_params'#10+
    '{'#10+
    '    float2 shadowMapSize;'#10+
    '    float3 lightDir;'#10+
    '    float3 eyePos;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 fragColor [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float3 color [[user(locn0)]];'#10+
    '    float4 lightProjPos [[user(locn1)]];'#10+
    '    float4 P [[user(locn2)]];'#10+
    '    float3 N [[user(locn3)]];'#10+
    '};'#10+

    'static inline __attribute__((always_inline))'#10+
    'float decodeDepth(thread const float4& rgba)'#10+
    '{'#10+
    '    return dot(rgba, float4(1.0, 0.0039215688593685626983642578125, 1.5378700481960549950599670410156e-05, 6.0308629201699659461155533790588e-08));'#10+
    '}'#10+

    'static inline __attribute__((always_inline))'#10+
    'float sampleShadow(thread const texture2d<float> shadowMap, thread const sampler shadowMapSmplr, thread float2& uv, thread const float& compare)'#10+
    '{'#10+
    '    uv.y = 1.0 - uv.y;'#10+
    '    float4 param = shadowMap.sample(shadowMapSmplr, float2(uv.x, uv.y));'#10+
    '    return step(compare, decodeDepth(param) + 0.001000000047497451305389404296875);'#10+
    '}'#10+

    'static inline __attribute__((always_inline))'#10+
    'float sampleShadowPCF(thread const texture2d<float> shadowMap, thread const sampler shadowMapSmplr, thread const float2& uv, thread const float2& smSize, thread const float& compare)'#10+
    '{'#10+
    '    float result = 0.0;'#10+
    '    for (int x = -2; x <= 2; x++)'#10+
    '    {'#10+
    '        for (int y = -2; y <= 2; y++)'#10+
    '        {'#10+
    '            float2 param = uv + (float2(float(x), float(y)) / smSize);'#10+
    '            float param_1 = compare;'#10+
    '            float _109 = sampleShadow(shadowMap, shadowMapSmplr, param, param_1);'#10+
    '            result += _109;'#10+
    '        }'#10+
    '    }'#10+
    '    return result * 0.039999999105930328369140625;'#10+
    '}'#10+

    'static inline __attribute__((always_inline))'#10+
    'float4 gamma(thread const float4& c)'#10+
    '{'#10+
    '    return float4(pow(c.xyz, float3(0.4545454680919647216796875)), c.w);'#10+
    '}'#10+

    'fragment main0_out main0(main0_in in [[stage_in]], constant fs_light_params& _149 [[buffer(0)]], texture2d<float> shadowMap [[texture(0)]], sampler shadowMapSmplr [[sampler(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    float3 _153 = fast::normalize(_149.lightDir);'#10+
    '    float3 _158 = fast::normalize(in.N);'#10+
    '    float _162 = dot(_158, _153);'#10+
    '    if (_162 > 0.0)'#10+
    '    {'#10+
    '        float3 _176 = in.lightProjPos.xyz / float3(in.lightProjPos.w);'#10+
    '        float2 param = (_176.xy + float2(1.0)) * 0.5;'#10+
    '        float2 param_1 = _149.shadowMapSize;'#10+
    '        float param_2 = _176.z;'#10+
    '        float _199 = sampleShadowPCF(shadowMap, shadowMapSmplr, param, param_1, param_2);'#10+
    '        out.fragColor = float4(float3((pow(fast::max(dot(reflect(-_153, _158), fast::normalize(_149.eyePos - in.P.xyz)), 0.0), 2.2000000476837158203125) * _162) * _199) + (in.color * (fast::max(_162 '+
      '* _199, 0.0) + 0.25)), 1.0);'#10+
    '    }'#10+
    '    else'#10+
    '    {'#10+
    '        out.fragColor = float4(in.color * 0.25, 1.0);'#10+
    '    }'#10+
    '    float4 param_3 = out.fragColor;'#10+
    '    out.fragColor = gamma(param_3);'#10+
    '    return out;'#10+
    '}';

{$ENDIF !SOKOL_METAL}

{$IFDEF SOKOL_METAL}
const
  SHADOWVS_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct vs_shadow_params'#10+
    '{'#10+
    '    float4x4 mvp;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float2 projZW [[user(locn0)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 position [[attribute(0)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant vs_shadow_params& _21 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = _21.mvp * in.position;'#10+
    '    out.projZW = out.gl_Position.zw;'#10+
    '    return out;'#10+
    '}';

const
  SHADOWFS_SOURCE_METAL_IOS =
    '#pragma clang diagnostic ignored "-Wmissing-prototypes"'#10+

    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 fragColor [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 projZW [[user(locn0)]];'#10+
    '};'#10+

    'static inline __attribute__((always_inline))'#10+
    'float4 encodeDepth(thread const float& v)'#10+
    '{'#10+
    '    float4 _25 = fract(float4(1.0, 255.0, 65025.0, 16581375.0) * v);'#10+
    '    return _25 - (_25.yzww * float4(0.0039215688593685626983642578125, 0.0039215688593685626983642578125, 0.0039215688593685626983642578125, 0.0));'#10+
    '}'#10+

    'fragment main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    float param = in.projZW.x / in.projZW.y;'#10+
    '    out.fragColor = encodeDepth(param);'#10+
    '    return out;'#10+
    '}';

const
  COLORVS_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct vs_light_params'#10+
    '{'#10+
    '    float4x4 model;'#10+
    '    float4x4 mvp;'#10+
    '    float4x4 lightMVP;'#10+
    '    float3 diffColor;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float3 color [[user(locn0)]];'#10+
    '    float4 lightProjPos [[user(locn1)]];'#10+
    '    float4 P [[user(locn2)]];'#10+
    '    float3 N [[user(locn3)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 position [[attribute(0)]];'#10+
    '    float3 normal [[attribute(1)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant vs_light_params& _22 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = _22.mvp * in.position;'#10+
    '    out.lightProjPos = _22.lightMVP * in.position;'#10+
    '    out.P = _22.model * in.position;'#10+
    '    out.N = (_22.model * float4(in.normal, 0.0)).xyz;'#10+
    '    out.color = _22.diffColor;'#10+
    '    return out;'#10+
    '}';

const
  COLORFS_SOURCE_METAL_IOS =
    '#pragma clang diagnostic ignored "-Wmissing-prototypes"'#10+

    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct fs_light_params'#10+
    '{'#10+
    '    float2 shadowMapSize;'#10+
    '    float3 lightDir;'#10+
    '    float3 eyePos;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 fragColor [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float3 color [[user(locn0)]];'#10+
    '    float4 lightProjPos [[user(locn1)]];'#10+
    '    float4 P [[user(locn2)]];'#10+
    '    float3 N [[user(locn3)]];'#10+
    '};'#10+

    'static inline __attribute__((always_inline))'#10+
    'float decodeDepth(thread const float4& rgba)'#10+
    '{'#10+
    '    return dot(rgba, float4(1.0, 0.0039215688593685626983642578125, 1.5378700481960549950599670410156e-05, 6.0308629201699659461155533790588e-08));'#10+
    '}'#10+

    'static inline __attribute__((always_inline))'#10+
    'float sampleShadow(thread const texture2d<float> shadowMap, thread const sampler shadowMapSmplr, thread float2& uv, thread const float& compare)'#10+
    '{'#10+
    '    uv.y = 1.0 - uv.y;'#10+
    '    float4 param = shadowMap.sample(shadowMapSmplr, float2(uv.x, uv.y));'#10+
    '    return step(compare, decodeDepth(param) + 0.001000000047497451305389404296875);'#10+
    '}'#10+

    'static inline __attribute__((always_inline))'#10+
    'float sampleShadowPCF(thread const texture2d<float> shadowMap, thread const sampler shadowMapSmplr, thread const float2& uv, thread const float2& smSize, thread const float& compare)'#10+
    '{'#10+
    '    float result = 0.0;'#10+
    '    for (int x = -2; x <= 2; x++)'#10+
    '    {'#10+
    '        for (int y = -2; y <= 2; y++)'#10+
    '        {'#10+
    '            float2 param = uv + (float2(float(x), float(y)) / smSize);'#10+
    '            float param_1 = compare;'#10+
    '            float _109 = sampleShadow(shadowMap, shadowMapSmplr, param, param_1);'#10+
    '            result += _109;'#10+
    '        }'#10+
    '    }'#10+
    '    return result * 0.039999999105930328369140625;'#10+
    '}'#10+

    'static inline __attribute__((always_inline))'#10+
    'float4 gamma(thread const float4& c)'#10+
    '{'#10+
    '    return float4(pow(c.xyz, float3(0.4545454680919647216796875)), c.w);'#10+
    '}'#10+

    'fragment main0_out main0(main0_in in [[stage_in]], constant fs_light_params& _149 [[buffer(0)]], texture2d<float> shadowMap [[texture(0)]], sampler shadowMapSmplr [[sampler(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    float3 _153 = fast::normalize(_149.lightDir);'#10+
    '    float3 _158 = fast::normalize(in.N);'#10+
    '    float _162 = dot(_158, _153);'#10+
    '    if (_162 > 0.0)'#10+
    '    {'#10+
    '        float3 _176 = in.lightProjPos.xyz / float3(in.lightProjPos.w);'#10+
    '        float2 param = (_176.xy + float2(1.0)) * 0.5;'#10+
    '        float2 param_1 = _149.shadowMapSize;'#10+
    '        float param_2 = _176.z;'#10+
    '        float _199 = sampleShadowPCF(shadowMap, shadowMapSmplr, param, param_1, param_2);'#10+
    '        out.fragColor = float4(float3((pow(fast::max(dot(reflect(-_153, _158), fast::normalize(_149.eyePos - in.P.xyz)), 0.0), 2.2000000476837158203125) * _162) * _199) + (in.color * (fast::max(_162 '+
      '* _199, 0.0) + 0.25)), 1.0);'#10+
    '    }'#10+
    '    else'#10+
    '    {'#10+
    '        out.fragColor = float4(in.color * 0.25, 1.0);'#10+
    '    }'#10+
    '    float4 param_3 = out.fragColor;'#10+
    '    out.fragColor = gamma(param_3);'#10+
    '    return out;'#10+
    '}';

{$ENDIF !SOKOL_METAL}

var
  GColorShaderDesc: TNativeShaderDesc;

procedure InitColorShaderDesc;
begin
  GColorShaderDesc.Init;
  GColorShaderDesc.Attrs[0].Init('position', 'TEXCOORD', 0);
  GColorShaderDesc.Attrs[1].Init('normal', 'TEXCOORD', 1);

  case TGfx.Backend of
    {$IFDEF SOKOL_GLCORE33}
    TBackend.GLCore33:
      begin
        GColorShaderDesc.VS.Source := COLORVS_SOURCE_GLSL330;
        GColorShaderDesc.FS.Source := COLORFS_SOURCE_GLSL330;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES2}
    TBackend.Gles2:
      begin
        GColorShaderDesc.VS.Source := COLORVS_SOURCE_GLSL100;
        GColorShaderDesc.FS.Source := COLORFS_SOURCE_GLSL100;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES3}
    TBackend.Gles3:
      begin
        GColorShaderDesc.VS.Source := COLORVS_SOURCE_GLSL300ES;
        GColorShaderDesc.FS.Source := COLORFS_SOURCE_GLSL300ES;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_D3D11}
    TBackend.D3D11:
      begin
        GColorShaderDesc.VS.Source := COLORVS_SOURCE_HLSL5;
        GColorShaderDesc.FS.Source := COLORFS_SOURCE_HLSL5;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalMacOS:
      begin
        GColorShaderDesc.VS.Source := COLORVS_SOURCE_METAL_MACOS;
        GColorShaderDesc.FS.Source := COLORFS_SOURCE_METAL_MACOS;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalIOS:
      begin
        GColorShaderDesc.VS.Source := COLORVS_SOURCE_METAL_IOS;
        GColorShaderDesc.FS.Source := COLORFS_SOURCE_METAL_IOS;
      end;
    {$ENDIF}
  else
    Assert(False)
  end;

  GColorShaderDesc.vs.uniform_blocks[0].size := 208;
  GColorShaderDesc.vs.uniform_blocks[0].layout := _SG_UNIFORMLAYOUT_STD140;
  if (TGfx.Backend.IsGL) then
    GColorShaderDesc.vs.uniform_blocks[0].uniforms[0].Init('vs_light_params', _SG_UNIFORMTYPE_FLOAT4, 13);
  GColorShaderDesc.fs.uniform_blocks[0].size := 48;
  GColorShaderDesc.fs.uniform_blocks[0].layout := _SG_UNIFORMLAYOUT_STD140;
  if (TGfx.Backend.IsGL) then
    GColorShaderDesc.fs.uniform_blocks[0].uniforms[0].Init('fs_light_params', _SG_UNIFORMTYPE_FLOAT4, 3);
  GColorShaderDesc.fs.images[0].Init('shadowMap', _SG_IMAGETYPE_2D, _SG_SAMPLERTYPE_FLOAT);
  GColorShaderDesc.&label := 'ColorShader';
end;

function ColorShaderDesc: PNativeShaderDesc;
begin
  if (GColorShaderDesc.VS.Entry = nil) then
    InitColorShaderDesc;

  Result := @GColorShaderDesc;
end;


var
  GShadowShaderDesc: TNativeShaderDesc;

procedure InitShadowShaderDesc;
begin
  GShadowShaderDesc.Init;
  GShadowShaderDesc.Attrs[0].Init('position', 'TEXCOORD', 0);

  case TGfx.Backend of
    {$IFDEF SOKOL_GLCORE33}
    TBackend.GLCore33:
      begin
        GShadowShaderDesc.VS.Source := SHADOWVS_SOURCE_GLSL330;
        GShadowShaderDesc.FS.Source := SHADOWFS_SOURCE_GLSL330;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES2}
    TBackend.Gles2:
      begin
        GShadowShaderDesc.VS.Source := SHADOWVS_SOURCE_GLSL100;
        GShadowShaderDesc.FS.Source := SHADOWFS_SOURCE_GLSL100;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES3}
    TBackend.Gles3:
      begin
        GShadowShaderDesc.VS.Source := SHADOWVS_SOURCE_GLSL300ES;
        GShadowShaderDesc.FS.Source := SHADOWFS_SOURCE_GLSL300ES;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_D3D11}
    TBackend.D3D11:
      begin
        GShadowShaderDesc.VS.Source := SHADOWVS_SOURCE_HLSL5;
        GShadowShaderDesc.FS.Source := SHADOWFS_SOURCE_HLSL5;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalMacOS:
      begin
        GShadowShaderDesc.VS.Source := SHADOWVS_SOURCE_METAL_MACOS;
        GShadowShaderDesc.FS.Source := SHADOWFS_SOURCE_METAL_MACOS;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalIOS:
      begin
        GShadowShaderDesc.VS.Source := SHADOWVS_SOURCE_METAL_IOS;
        GShadowShaderDesc.FS.Source := SHADOWFS_SOURCE_METAL_IOS;
      end;
    {$ENDIF}
  else
    Assert(False)
  end;

  GShadowShaderDesc.vs.uniform_blocks[0].size := 64;
  GShadowShaderDesc.vs.uniform_blocks[0].layout := _SG_UNIFORMLAYOUT_STD140;
  if (TGfx.Backend.IsGL) then
    GShadowShaderDesc.vs.uniform_blocks[0].uniforms[0].Init('vs_shadow_params', _SG_UNIFORMTYPE_FLOAT4, 4);
  GShadowShaderDesc.&label := 'ShadowShader';
end;

function ShadowShaderDesc: PNativeShaderDesc;
begin
  if (GShadowShaderDesc.VS.Entry = nil) then
    InitShadowShaderDesc;

  Result := @GShadowShaderDesc;
end;

end.
