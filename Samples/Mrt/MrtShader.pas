unit MrtShader;
{ #version:1# (machine generated, don't edit!)

  Generated by sokol-shdc (https://github.com/floooh/sokol-tools)
  With Delphi modifications (https://github.com/neslib/Neslib.Sokol.Tools)

  Cmdline: sokol-shdc --input MrtShader.glsl --output MrtShader.pas

  Overview:

    Shader program 'dbg':
      Get shader desc: DbgShaderDesc()
      Vertex shader: vs_dbg
        Attribute slots:
          ATTR_VS_DBG_POS = 0
      Fragment shader: fs_dbg
        Image 'tex':
          Type: _SG_IMAGETYPE_2D
          Component Type: _SG_SAMPLERTYPE_FLOAT
          Bind slot: SLOT_TEX = 0

    Shader program 'fsq':
      Get shader desc: FsqShaderDesc()
      Vertex shader: vs_fsq
        Attribute slots:
          ATTR_VS_FSQ_POS = 0
        Uniform block 'fsq_params':
          Delphi record: TFsqParams
          Bind slot: SLOT_FSQ_PARAMS = 0
      Fragment shader: fs_fsq
        Image 'tex0':
          Type: _SG_IMAGETYPE_2D
          Component Type: _SG_SAMPLERTYPE_FLOAT
          Bind slot: SLOT_TEX0 = 0
        Image 'tex1':
          Type: _SG_IMAGETYPE_2D
          Component Type: _SG_SAMPLERTYPE_FLOAT
          Bind slot: SLOT_TEX1 = 1
        Image 'tex2':
          Type: _SG_IMAGETYPE_2D
          Component Type: _SG_SAMPLERTYPE_FLOAT
          Bind slot: SLOT_TEX2 = 2

    Shader program 'offscreen':
      Get shader desc: OffscreenShaderDesc()
      Vertex shader: vs_offscreen
        Attribute slots:
          ATTR_VS_OFFSCREEN_POS = 0
          ATTR_VS_OFFSCREEN_BRIGHT0 = 1
        Uniform block 'offscreen_params':
          Delphi record: TOffscreenParams
          Bind slot: SLOT_OFFSCREEN_PARAMS = 0
      Fragment shader: fs_offscreen


  Shader descriptor records:

    var DbgShader := TShader.Create(DbgShaderDesc);
    var FsqShader := TShader.Create(FsqShaderDesc);
    var OffscreenShader := TShader.Create(OffscreenShaderDesc);

  Vertex attribute locations for vertex shader 'vs_offscreen':

    var PipDesc: TPipelineDesc;
    PipDesc.Init;
    PipDesc.Attrs[ATTR_VS_OFFSCREEN_POS]. ...
    PipDesc.Attrs[ATTR_VS_OFFSCREEN_BRIGHT0]. ...
    PipDesc. ...
    var Pip := TPipeline.Create(PipDesc);

  Vertex attribute locations for vertex shader 'vs_fsq':

    var PipDesc: TPipelineDesc;
    PipDesc.Init;
    PipDesc.Attrs[ATTR_VS_FSQ_POS]. ...
    PipDesc. ...
    var Pip := TPipeline.Create(PipDesc);

  Vertex attribute locations for vertex shader 'vs_dbg':

    var PipDesc: TPipelineDesc;
    PipDesc.Init;
    PipDesc.Attrs[ATTR_VS_DBG_POS]. ...
    PipDesc. ...
    var Pip := TPipeline.Create(PipDesc);

  Image bind slots, use as index in TBindings.VSImages[] or .FSImages[]:

    SLOT_TEX0 = 0;
    SLOT_TEX1 = 1;
    SLOT_TEX2 = 2;
    SLOT_TEX = 0;

  Bind slot and Delphi record for uniform block 'OffscreenParams':

    OffscreenParams: TOffscreenParams;
    OffscreenParams.Mvp := ...;
    TGfx.ApplyUniforms(TShaderStage.[VertexShader|FragmentShader], SLOT_OFFSCREEN_PARAMS, TRange.Create(OffscreenParams));

  Bind slot and Delphi record for uniform block 'FsqParams':

    FsqParams: TFsqParams;
    FsqParams.Offset := ...;
    TGfx.ApplyUniforms(TShaderStage.[VertexShader|FragmentShader], SLOT_FSQ_PARAMS, TRange.Create(FsqParams));

}

{$INCLUDE 'Neslib.Sokol.inc'}

interface

uses
  Neslib.FastMath,
  Neslib.Sokol.Gfx;

const
  ATTR_VS_OFFSCREEN_POS = 0;
  ATTR_VS_OFFSCREEN_BRIGHT0 = 1;
  ATTR_VS_FSQ_POS = 0;
  ATTR_VS_DBG_POS = 0;

const
  SLOT_TEX0 = 0;
  SLOT_TEX1 = 1;
  SLOT_TEX2 = 2;
  SLOT_TEX = 0;

const
  SLOT_OFFSCREEN_PARAMS = 0;

type
  TOffscreenParams = packed record
  public
    Mvp: TMatrix4;
  end;

const
  SLOT_FSQ_PARAMS = 0;

type
  TFsqParams = packed record
  public
    Offset: TVector2;
    _Pad8: array [0..7] of UInt8;
  end;

function DbgShaderDesc: PNativeShaderDesc;
function FsqShaderDesc: PNativeShaderDesc;
function OffscreenShaderDesc: PNativeShaderDesc;

implementation

uses
  Neslib.Sokol.Api;

{$IFDEF SOKOL_GLCORE33}
const
  VS_OFFSCREEN_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform vec4 offscreen_params[4];'#10+
    'layout(location = 0) in vec4 pos;'#10+
    'out float bright;'#10+
    'layout(location = 1) in float bright0;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(offscreen_params[0], offscreen_params[1], offscreen_params[2], offscreen_params[3]) * pos;'#10+
    '    bright = bright0;'#10+
    '}';

const
  FS_OFFSCREEN_SOURCE_GLSL330 =
    '#version 330'#10+

    'layout(location = 0) out vec4 frag_color_0;'#10+
    'in float bright;'#10+
    'layout(location = 1) out vec4 frag_color_1;'#10+
    'layout(location = 2) out vec4 frag_color_2;'#10+

    'void main()'#10+
    '{'#10+
    '    frag_color_0 = vec4(bright, 0.0, 0.0, 1.0);'#10+
    '    frag_color_1 = vec4(0.0, bright, 0.0, 1.0);'#10+
    '    frag_color_2 = vec4(0.0, 0.0, bright, 1.0);'#10+
    '}';

const
  VS_FSQ_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform vec4 fsq_params[1];'#10+
    'layout(location = 0) in vec2 pos;'#10+
    'out vec2 uv0;'#10+
    'out vec2 uv1;'#10+
    'out vec2 uv2;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = vec4((pos * 2.0) - vec2(1.0), 0.5, 1.0);'#10+
    '    uv0 = pos + vec2(fsq_params[0].x, 0.0);'#10+
    '    uv1 = pos + vec2(0.0, fsq_params[0].y);'#10+
    '    uv2 = pos;'#10+
    '    gl_Position.y = -gl_Position.y;'#10+
    '}';

const
  FS_FSQ_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform sampler2D tex0;'#10+
    'uniform sampler2D tex1;'#10+
    'uniform sampler2D tex2;'#10+

    'in vec2 uv0;'#10+
    'in vec2 uv1;'#10+
    'in vec2 uv2;'#10+
    'layout(location = 0) out vec4 frag_color;'#10+

    'void main()'#10+
    '{'#10+
    '    frag_color = vec4((texture(tex0, uv0).xyz + texture(tex1, uv1).xyz) + texture(tex2, uv2).xyz, 1.0);'#10+
    '}';

const
  VS_DBG_SOURCE_GLSL330 =
    '#version 330'#10+

    'layout(location = 0) in vec2 pos;'#10+
    'out vec2 uv;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = vec4((pos * 2.0) - vec2(1.0), 0.5, 1.0);'#10+
    '    uv = pos;'#10+
    '    gl_Position.y = -gl_Position.y;'#10+
    '}';

const
  FS_DBG_SOURCE_GLSL330 =
    '#version 330'#10+

    'uniform sampler2D tex;'#10+

    'layout(location = 0) out vec4 frag_color;'#10+
    'in vec2 uv;'#10+

    'void main()'#10+
    '{'#10+
    '    frag_color = vec4(texture(tex, uv).xyz, 1.0);'#10+
    '}';

{$ENDIF !SOKOL_GLCORE33}

{$IFDEF SOKOL_GLES2}
const
  VS_OFFSCREEN_SOURCE_GLSL100 =
    '#version 100'#10+

    'uniform vec4 offscreen_params[4];'#10+
    'attribute vec4 pos;'#10+
    'varying float bright;'#10+
    'attribute float bright0;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(offscreen_params[0], offscreen_params[1], offscreen_params[2], offscreen_params[3]) * pos;'#10+
    '    bright = bright0;'#10+
    '}';

const
  FS_OFFSCREEN_SOURCE_GLSL100 =
    '#version 100'#10+
    '#extension GL_EXT_draw_buffers : require'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'varying highp float bright;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_FragData[0] = vec4(bright, 0.0, 0.0, 1.0);'#10+
    '    gl_FragData[1] = vec4(0.0, bright, 0.0, 1.0);'#10+
    '    gl_FragData[2] = vec4(0.0, 0.0, bright, 1.0);'#10+
    '}';

const
  VS_FSQ_SOURCE_GLSL100 =
    '#version 100'#10+

    'uniform vec4 fsq_params[1];'#10+
    'attribute vec2 pos;'#10+
    'varying vec2 uv0;'#10+
    'varying vec2 uv1;'#10+
    'varying vec2 uv2;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = vec4((pos * 2.0) - vec2(1.0), 0.5, 1.0);'#10+
    '    uv0 = pos + vec2(fsq_params[0].x, 0.0);'#10+
    '    uv1 = pos + vec2(0.0, fsq_params[0].y);'#10+
    '    uv2 = pos;'#10+
    '    gl_Position.y = -gl_Position.y;'#10+
    '}';

const
  FS_FSQ_SOURCE_GLSL100 =
    '#version 100'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'uniform highp sampler2D tex0;'#10+
    'uniform highp sampler2D tex1;'#10+
    'uniform highp sampler2D tex2;'#10+

    'varying highp vec2 uv0;'#10+
    'varying highp vec2 uv1;'#10+
    'varying highp vec2 uv2;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_FragData[0] = vec4((texture2D(tex0, uv0).xyz + texture2D(tex1, uv1).xyz) + texture2D(tex2, uv2).xyz, 1.0);'#10+
    '}';

const
  VS_DBG_SOURCE_GLSL100 =
    '#version 100'#10+

    'attribute vec2 pos;'#10+
    'varying vec2 uv;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = vec4((pos * 2.0) - vec2(1.0), 0.5, 1.0);'#10+
    '    uv = pos;'#10+
    '    gl_Position.y = -gl_Position.y;'#10+
    '}';

const
  FS_DBG_SOURCE_GLSL100 =
    '#version 100'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'uniform highp sampler2D tex;'#10+

    'varying highp vec2 uv;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_FragData[0] = vec4(texture2D(tex, uv).xyz, 1.0);'#10+
    '}';

{$ENDIF !SOKOL_GLES2}

{$IFDEF SOKOL_GLES3}
const
  VS_OFFSCREEN_SOURCE_GLSL300ES =
    '#version 300 es'#10+

    'uniform vec4 offscreen_params[4];'#10+
    'layout(location = 0) in vec4 pos;'#10+
    'out float bright;'#10+
    'layout(location = 1) in float bright0;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = mat4(offscreen_params[0], offscreen_params[1], offscreen_params[2], offscreen_params[3]) * pos;'#10+
    '    bright = bright0;'#10+
    '}';

const
  FS_OFFSCREEN_SOURCE_GLSL300ES =
    '#version 300 es'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'layout(location = 0) out highp vec4 frag_color_0;'#10+
    'in highp float bright;'#10+
    'layout(location = 1) out highp vec4 frag_color_1;'#10+
    'layout(location = 2) out highp vec4 frag_color_2;'#10+

    'void main()'#10+
    '{'#10+
    '    frag_color_0 = vec4(bright, 0.0, 0.0, 1.0);'#10+
    '    frag_color_1 = vec4(0.0, bright, 0.0, 1.0);'#10+
    '    frag_color_2 = vec4(0.0, 0.0, bright, 1.0);'#10+
    '}';

const
  VS_FSQ_SOURCE_GLSL300ES =
    '#version 300 es'#10+

    'uniform vec4 fsq_params[1];'#10+
    'layout(location = 0) in vec2 pos;'#10+
    'out vec2 uv0;'#10+
    'out vec2 uv1;'#10+
    'out vec2 uv2;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = vec4((pos * 2.0) - vec2(1.0), 0.5, 1.0);'#10+
    '    uv0 = pos + vec2(fsq_params[0].x, 0.0);'#10+
    '    uv1 = pos + vec2(0.0, fsq_params[0].y);'#10+
    '    uv2 = pos;'#10+
    '    gl_Position.y = -gl_Position.y;'#10+
    '}';

const
  FS_FSQ_SOURCE_GLSL300ES =
    '#version 300 es'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'uniform highp sampler2D tex0;'#10+
    'uniform highp sampler2D tex1;'#10+
    'uniform highp sampler2D tex2;'#10+

    'in highp vec2 uv0;'#10+
    'in highp vec2 uv1;'#10+
    'in highp vec2 uv2;'#10+
    'layout(location = 0) out highp vec4 frag_color;'#10+

    'void main()'#10+
    '{'#10+
    '    frag_color = vec4((texture(tex0, uv0).xyz + texture(tex1, uv1).xyz) + texture(tex2, uv2).xyz, 1.0);'#10+
    '}';

const
  VS_DBG_SOURCE_GLSL300ES =
    '#version 300 es'#10+

    'layout(location = 0) in vec2 pos;'#10+
    'out vec2 uv;'#10+

    'void main()'#10+
    '{'#10+
    '    gl_Position = vec4((pos * 2.0) - vec2(1.0), 0.5, 1.0);'#10+
    '    uv = pos;'#10+
    '    gl_Position.y = -gl_Position.y;'#10+
    '}';

const
  FS_DBG_SOURCE_GLSL300ES =
    '#version 300 es'#10+
    'precision mediump float;'#10+
    'precision highp int;'#10+

    'uniform highp sampler2D tex;'#10+

    'layout(location = 0) out highp vec4 frag_color;'#10+
    'in highp vec2 uv;'#10+

    'void main()'#10+
    '{'#10+
    '    frag_color = vec4(texture(tex, uv).xyz, 1.0);'#10+
    '}';

{$ENDIF !SOKOL_GLES3}

{$IFDEF SOKOL_D3D11}
const
  VS_OFFSCREEN_SOURCE_HLSL5 =
    'cbuffer offscreen_params : register(b0)'#10+
    '{'#10+
    '    row_major float4x4 _21_mvp : packoffset(c0);'#10+
    '};'#10+


    'static float4 gl_Position;'#10+
    'static float4 pos;'#10+
    'static float bright;'#10+
    'static float bright0;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float4 pos : TEXCOORD0;'#10+
    '    float bright0 : TEXCOORD1;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float bright : TEXCOORD0;'#10+
    '    float4 gl_Position : SV_Position;'#10+
    '};'#10+

    'void vert_main()'#10+
    '{'#10+
    '    gl_Position = mul(pos, _21_mvp);'#10+
    '    bright = bright0;'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    pos = stage_input.pos;'#10+
    '    bright0 = stage_input.bright0;'#10+
    '    vert_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.gl_Position = gl_Position;'#10+
    '    stage_output.bright = bright;'#10+
    '    return stage_output;'#10+
    '}';

const
  FS_OFFSCREEN_SOURCE_HLSL5 =
    'static float4 frag_color_0;'#10+
    'static float bright;'#10+
    'static float4 frag_color_1;'#10+
    'static float4 frag_color_2;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float bright : TEXCOORD0;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 frag_color_0 : SV_Target0;'#10+
    '    float4 frag_color_1 : SV_Target1;'#10+
    '    float4 frag_color_2 : SV_Target2;'#10+
    '};'#10+

    'void frag_main()'#10+
    '{'#10+
    '    frag_color_0 = float4(bright, 0.0f, 0.0f, 1.0f);'#10+
    '    frag_color_1 = float4(0.0f, bright, 0.0f, 1.0f);'#10+
    '    frag_color_2 = float4(0.0f, 0.0f, bright, 1.0f);'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    bright = stage_input.bright;'#10+
    '    frag_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.frag_color_0 = frag_color_0;'#10+
    '    stage_output.frag_color_1 = frag_color_1;'#10+
    '    stage_output.frag_color_2 = frag_color_2;'#10+
    '    return stage_output;'#10+
    '}';

const
  VS_FSQ_SOURCE_HLSL5 =
    'cbuffer fsq_params : register(b0)'#10+
    '{'#10+
    '    float2 _38_offset : packoffset(c0);'#10+
    '};'#10+


    'static float4 gl_Position;'#10+
    'static float2 pos;'#10+
    'static float2 uv0;'#10+
    'static float2 uv1;'#10+
    'static float2 uv2;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float2 pos : TEXCOORD0;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float2 uv0 : TEXCOORD0;'#10+
    '    float2 uv1 : TEXCOORD1;'#10+
    '    float2 uv2 : TEXCOORD2;'#10+
    '    float4 gl_Position : SV_Position;'#10+
    '};'#10+

    'void vert_main()'#10+
    '{'#10+
    '    gl_Position = float4((pos * 2.0f) - 1.0f.xx, 0.5f, 1.0f);'#10+
    '    uv0 = pos + float2(_38_offset.x, 0.0f);'#10+
    '    uv1 = pos + float2(0.0f, _38_offset.y);'#10+
    '    uv2 = pos;'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    pos = stage_input.pos;'#10+
    '    vert_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.gl_Position = gl_Position;'#10+
    '    stage_output.uv0 = uv0;'#10+
    '    stage_output.uv1 = uv1;'#10+
    '    stage_output.uv2 = uv2;'#10+
    '    return stage_output;'#10+
    '}';

const
  FS_FSQ_SOURCE_HLSL5 =
    'Texture2D<float4> tex0 : register(t0);'#10+
    'SamplerState _tex0_sampler : register(s0);'#10+
    'Texture2D<float4> tex1 : register(t1);'#10+
    'SamplerState _tex1_sampler : register(s1);'#10+
    'Texture2D<float4> tex2 : register(t2);'#10+
    'SamplerState _tex2_sampler : register(s2);'#10+

    'static float2 uv0;'#10+
    'static float2 uv1;'#10+
    'static float2 uv2;'#10+
    'static float4 frag_color;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float2 uv0 : TEXCOORD0;'#10+
    '    float2 uv1 : TEXCOORD1;'#10+
    '    float2 uv2 : TEXCOORD2;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 frag_color : SV_Target0;'#10+
    '};'#10+

    'void frag_main()'#10+
    '{'#10+
    '    frag_color = float4((tex0.Sample(_tex0_sampler, uv0).xyz + tex1.Sample(_tex1_sampler, uv1).xyz) + tex2.Sample(_tex2_sampler, uv2).xyz, 1.0f);'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    uv0 = stage_input.uv0;'#10+
    '    uv1 = stage_input.uv1;'#10+
    '    uv2 = stage_input.uv2;'#10+
    '    frag_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.frag_color = frag_color;'#10+
    '    return stage_output;'#10+
    '}';

const
  VS_DBG_SOURCE_HLSL5 =
    'static float4 gl_Position;'#10+
    'static float2 pos;'#10+
    'static float2 uv;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float2 pos : TEXCOORD0;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float2 uv : TEXCOORD0;'#10+
    '    float4 gl_Position : SV_Position;'#10+
    '};'#10+

    'void vert_main()'#10+
    '{'#10+
    '    gl_Position = float4((pos * 2.0f) - 1.0f.xx, 0.5f, 1.0f);'#10+
    '    uv = pos;'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    pos = stage_input.pos;'#10+
    '    vert_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.gl_Position = gl_Position;'#10+
    '    stage_output.uv = uv;'#10+
    '    return stage_output;'#10+
    '}';

const
  FS_DBG_SOURCE_HLSL5 =
    'Texture2D<float4> tex : register(t0);'#10+
    'SamplerState _tex_sampler : register(s0);'#10+

    'static float4 frag_color;'#10+
    'static float2 uv;'#10+

    'struct SPIRV_Cross_Input'#10+
    '{'#10+
    '    float2 uv : TEXCOORD0;'#10+
    '};'#10+

    'struct SPIRV_Cross_Output'#10+
    '{'#10+
    '    float4 frag_color : SV_Target0;'#10+
    '};'#10+

    'void frag_main()'#10+
    '{'#10+
    '    frag_color = float4(tex.Sample(_tex_sampler, uv).xyz, 1.0f);'#10+
    '}'#10+

    'SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)'#10+
    '{'#10+
    '    uv = stage_input.uv;'#10+
    '    frag_main();'#10+
    '    SPIRV_Cross_Output stage_output;'#10+
    '    stage_output.frag_color = frag_color;'#10+
    '    return stage_output;'#10+
    '}';

{$ENDIF !SOKOL_D3D11}

{$IFDEF SOKOL_METAL}
const
  VS_OFFSCREEN_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct offscreen_params'#10+
    '{'#10+
    '    float4x4 mvp;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float bright [[user(locn0)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 pos [[attribute(0)]];'#10+
    '    float bright0 [[attribute(1)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant offscreen_params& _21 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = _21.mvp * in.pos;'#10+
    '    out.bright = in.bright0;'#10+
    '    return out;'#10+
    '}';

const
  FS_OFFSCREEN_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color_0 [[color(0)]];'#10+
    '    float4 frag_color_1 [[color(1)]];'#10+
    '    float4 frag_color_2 [[color(2)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float bright [[user(locn0)]];'#10+
    '};'#10+

    'fragment main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.frag_color_0 = float4(in.bright, 0.0, 0.0, 1.0);'#10+
    '    out.frag_color_1 = float4(0.0, in.bright, 0.0, 1.0);'#10+
    '    out.frag_color_2 = float4(0.0, 0.0, in.bright, 1.0);'#10+
    '    return out;'#10+
    '}';

const
  VS_FSQ_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct fsq_params'#10+
    '{'#10+
    '    float2 offset;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float2 uv0 [[user(locn0)]];'#10+
    '    float2 uv1 [[user(locn1)]];'#10+
    '    float2 uv2 [[user(locn2)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 pos [[attribute(0)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant fsq_params& _38 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = float4((in.pos * 2.0) - float2(1.0), 0.5, 1.0);'#10+
    '    out.uv0 = in.pos + float2(_38.offset.x, 0.0);'#10+
    '    out.uv1 = in.pos + float2(0.0, _38.offset.y);'#10+
    '    out.uv2 = in.pos;'#10+
    '    return out;'#10+
    '}';

const
  FS_FSQ_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 uv0 [[user(locn0)]];'#10+
    '    float2 uv1 [[user(locn1)]];'#10+
    '    float2 uv2 [[user(locn2)]];'#10+
    '};'#10+

    'fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> tex0 [[texture(0)]], texture2d<float> tex1 [[texture(1)]], texture2d<float> tex2 [[texture(2)]], sampler tex0Smplr [[sampler(0)]], '+
      'sampler tex1Smplr [[sampler(1)]], sampler tex2Smplr [[sampler(2)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.frag_color = float4((tex0.sample(tex0Smplr, in.uv0).xyz + tex1.sample(tex1Smplr, in.uv1).xyz) + tex2.sample(tex2Smplr, in.uv2).xyz, 1.0);'#10+
    '    return out;'#10+
    '}';

const
  VS_DBG_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float2 uv [[user(locn0)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 pos [[attribute(0)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = float4((in.pos * 2.0) - float2(1.0), 0.5, 1.0);'#10+
    '    out.uv = in.pos;'#10+
    '    return out;'#10+
    '}';

const
  FS_DBG_SOURCE_METAL_MACOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 uv [[user(locn0)]];'#10+
    '};'#10+

    'fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.frag_color = float4(tex.sample(texSmplr, in.uv).xyz, 1.0);'#10+
    '    return out;'#10+
    '}';

{$ENDIF !SOKOL_METAL}

{$IFDEF SOKOL_METAL}
const
  VS_OFFSCREEN_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct offscreen_params'#10+
    '{'#10+
    '    float4x4 mvp;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float bright [[user(locn0)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float4 pos [[attribute(0)]];'#10+
    '    float bright0 [[attribute(1)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant offscreen_params& _21 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = _21.mvp * in.pos;'#10+
    '    out.bright = in.bright0;'#10+
    '    return out;'#10+
    '}';

const
  FS_OFFSCREEN_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color_0 [[color(0)]];'#10+
    '    float4 frag_color_1 [[color(1)]];'#10+
    '    float4 frag_color_2 [[color(2)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float bright [[user(locn0)]];'#10+
    '};'#10+

    'fragment main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.frag_color_0 = float4(in.bright, 0.0, 0.0, 1.0);'#10+
    '    out.frag_color_1 = float4(0.0, in.bright, 0.0, 1.0);'#10+
    '    out.frag_color_2 = float4(0.0, 0.0, in.bright, 1.0);'#10+
    '    return out;'#10+
    '}';

const
  VS_FSQ_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct fsq_params'#10+
    '{'#10+
    '    float2 offset;'#10+
    '};'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float2 uv0 [[user(locn0)]];'#10+
    '    float2 uv1 [[user(locn1)]];'#10+
    '    float2 uv2 [[user(locn2)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 pos [[attribute(0)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]], constant fsq_params& _38 [[buffer(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = float4((in.pos * 2.0) - float2(1.0), 0.5, 1.0);'#10+
    '    out.uv0 = in.pos + float2(_38.offset.x, 0.0);'#10+
    '    out.uv1 = in.pos + float2(0.0, _38.offset.y);'#10+
    '    out.uv2 = in.pos;'#10+
    '    return out;'#10+
    '}';

const
  FS_FSQ_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 uv0 [[user(locn0)]];'#10+
    '    float2 uv1 [[user(locn1)]];'#10+
    '    float2 uv2 [[user(locn2)]];'#10+
    '};'#10+

    'fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> tex0 [[texture(0)]], texture2d<float> tex1 [[texture(1)]], texture2d<float> tex2 [[texture(2)]], sampler tex0Smplr [[sampler(0)]], '+
      'sampler tex1Smplr [[sampler(1)]], sampler tex2Smplr [[sampler(2)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.frag_color = float4((tex0.sample(tex0Smplr, in.uv0).xyz + tex1.sample(tex1Smplr, in.uv1).xyz) + tex2.sample(tex2Smplr, in.uv2).xyz, 1.0);'#10+
    '    return out;'#10+
    '}';

const
  VS_DBG_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float2 uv [[user(locn0)]];'#10+
    '    float4 gl_Position [[position]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 pos [[attribute(0)]];'#10+
    '};'#10+

    'vertex main0_out main0(main0_in in [[stage_in]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.gl_Position = float4((in.pos * 2.0) - float2(1.0), 0.5, 1.0);'#10+
    '    out.uv = in.pos;'#10+
    '    return out;'#10+
    '}';

const
  FS_DBG_SOURCE_METAL_IOS =
    '#include <metal_stdlib>'#10+
    '#include <simd/simd.h>'#10+

    'using namespace metal;'#10+

    'struct main0_out'#10+
    '{'#10+
    '    float4 frag_color [[color(0)]];'#10+
    '};'#10+

    'struct main0_in'#10+
    '{'#10+
    '    float2 uv [[user(locn0)]];'#10+
    '};'#10+

    'fragment main0_out main0(main0_in in [[stage_in]], texture2d<float> tex [[texture(0)]], sampler texSmplr [[sampler(0)]])'#10+
    '{'#10+
    '    main0_out out = {};'#10+
    '    out.frag_color = float4(tex.sample(texSmplr, in.uv).xyz, 1.0);'#10+
    '    return out;'#10+
    '}';

{$ENDIF !SOKOL_METAL}

var
  GDbgShaderDesc: TNativeShaderDesc;

procedure InitDbgShaderDesc;
begin
  GDbgShaderDesc.Init;
  GDbgShaderDesc.Attrs[0].Init('pos', 'TEXCOORD', 0);

  case TGfx.Backend of
    {$IFDEF SOKOL_GLCORE33}
    TBackend.GLCore33:
      begin
        GDbgShaderDesc.VS.Source := VS_DBG_SOURCE_GLSL330;
        GDbgShaderDesc.FS.Source := FS_DBG_SOURCE_GLSL330;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES2}
    TBackend.Gles2:
      begin
        GDbgShaderDesc.VS.Source := VS_DBG_SOURCE_GLSL100;
        GDbgShaderDesc.FS.Source := FS_DBG_SOURCE_GLSL100;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES3}
    TBackend.Gles3:
      begin
        GDbgShaderDesc.VS.Source := VS_DBG_SOURCE_GLSL300ES;
        GDbgShaderDesc.FS.Source := FS_DBG_SOURCE_GLSL300ES;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_D3D11}
    TBackend.D3D11:
      begin
        GDbgShaderDesc.VS.Source := VS_DBG_SOURCE_HLSL5;
        GDbgShaderDesc.FS.Source := FS_DBG_SOURCE_HLSL5;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalMacOS:
      begin
        GDbgShaderDesc.VS.Source := VS_DBG_SOURCE_METAL_MACOS;
        GDbgShaderDesc.FS.Source := FS_DBG_SOURCE_METAL_MACOS;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalIOS:
      begin
        GDbgShaderDesc.VS.Source := VS_DBG_SOURCE_METAL_IOS;
        GDbgShaderDesc.FS.Source := FS_DBG_SOURCE_METAL_IOS;
      end;
    {$ENDIF}
  else
    Assert(False)
  end;

  GDbgShaderDesc.fs.images[0].Init('tex', _SG_IMAGETYPE_2D, _SG_SAMPLERTYPE_FLOAT);
  GDbgShaderDesc.&label := 'DbgShader';
end;

function DbgShaderDesc: PNativeShaderDesc;
begin
  if (GDbgShaderDesc.VS.Entry = nil) then
    InitDbgShaderDesc;

  Result := @GDbgShaderDesc;
end;


var
  GFsqShaderDesc: TNativeShaderDesc;

procedure InitFsqShaderDesc;
begin
  GFsqShaderDesc.Init;
  GFsqShaderDesc.Attrs[0].Init('pos', 'TEXCOORD', 0);

  case TGfx.Backend of
    {$IFDEF SOKOL_GLCORE33}
    TBackend.GLCore33:
      begin
        GFsqShaderDesc.VS.Source := VS_FSQ_SOURCE_GLSL330;
        GFsqShaderDesc.FS.Source := FS_FSQ_SOURCE_GLSL330;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES2}
    TBackend.Gles2:
      begin
        GFsqShaderDesc.VS.Source := VS_FSQ_SOURCE_GLSL100;
        GFsqShaderDesc.FS.Source := FS_FSQ_SOURCE_GLSL100;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES3}
    TBackend.Gles3:
      begin
        GFsqShaderDesc.VS.Source := VS_FSQ_SOURCE_GLSL300ES;
        GFsqShaderDesc.FS.Source := FS_FSQ_SOURCE_GLSL300ES;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_D3D11}
    TBackend.D3D11:
      begin
        GFsqShaderDesc.VS.Source := VS_FSQ_SOURCE_HLSL5;
        GFsqShaderDesc.FS.Source := FS_FSQ_SOURCE_HLSL5;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalMacOS:
      begin
        GFsqShaderDesc.VS.Source := VS_FSQ_SOURCE_METAL_MACOS;
        GFsqShaderDesc.FS.Source := FS_FSQ_SOURCE_METAL_MACOS;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalIOS:
      begin
        GFsqShaderDesc.VS.Source := VS_FSQ_SOURCE_METAL_IOS;
        GFsqShaderDesc.FS.Source := FS_FSQ_SOURCE_METAL_IOS;
      end;
    {$ENDIF}
  else
    Assert(False)
  end;

  GFsqShaderDesc.vs.uniform_blocks[0].size := 16;
  GFsqShaderDesc.vs.uniform_blocks[0].layout := _SG_UNIFORMLAYOUT_STD140;
  if (TGfx.Backend.IsGL) then
    GFsqShaderDesc.vs.uniform_blocks[0].uniforms[0].Init('fsq_params', _SG_UNIFORMTYPE_FLOAT4, 1);
  GFsqShaderDesc.fs.images[0].Init('tex0', _SG_IMAGETYPE_2D, _SG_SAMPLERTYPE_FLOAT);
  GFsqShaderDesc.fs.images[1].Init('tex1', _SG_IMAGETYPE_2D, _SG_SAMPLERTYPE_FLOAT);
  GFsqShaderDesc.fs.images[2].Init('tex2', _SG_IMAGETYPE_2D, _SG_SAMPLERTYPE_FLOAT);
  GFsqShaderDesc.&label := 'FsqShader';
end;

function FsqShaderDesc: PNativeShaderDesc;
begin
  if (GFsqShaderDesc.VS.Entry = nil) then
    InitFsqShaderDesc;

  Result := @GFsqShaderDesc;
end;


var
  GOffscreenShaderDesc: TNativeShaderDesc;

procedure InitOffscreenShaderDesc;
begin
  GOffscreenShaderDesc.Init;
  GOffscreenShaderDesc.Attrs[0].Init('pos', 'TEXCOORD', 0);
  GOffscreenShaderDesc.Attrs[1].Init('bright0', 'TEXCOORD', 1);

  case TGfx.Backend of
    {$IFDEF SOKOL_GLCORE33}
    TBackend.GLCore33:
      begin
        GOffscreenShaderDesc.VS.Source := VS_OFFSCREEN_SOURCE_GLSL330;
        GOffscreenShaderDesc.FS.Source := FS_OFFSCREEN_SOURCE_GLSL330;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES2}
    TBackend.Gles2:
      begin
        GOffscreenShaderDesc.VS.Source := VS_OFFSCREEN_SOURCE_GLSL100;
        GOffscreenShaderDesc.FS.Source := FS_OFFSCREEN_SOURCE_GLSL100;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_GLES3}
    TBackend.Gles3:
      begin
        GOffscreenShaderDesc.VS.Source := VS_OFFSCREEN_SOURCE_GLSL300ES;
        GOffscreenShaderDesc.FS.Source := FS_OFFSCREEN_SOURCE_GLSL300ES;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_D3D11}
    TBackend.D3D11:
      begin
        GOffscreenShaderDesc.VS.Source := VS_OFFSCREEN_SOURCE_HLSL5;
        GOffscreenShaderDesc.FS.Source := FS_OFFSCREEN_SOURCE_HLSL5;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalMacOS:
      begin
        GOffscreenShaderDesc.VS.Source := VS_OFFSCREEN_SOURCE_METAL_MACOS;
        GOffscreenShaderDesc.FS.Source := FS_OFFSCREEN_SOURCE_METAL_MACOS;
      end;
    {$ENDIF}

    {$IFDEF SOKOL_METAL}
    TBackend.MetalIOS:
      begin
        GOffscreenShaderDesc.VS.Source := VS_OFFSCREEN_SOURCE_METAL_IOS;
        GOffscreenShaderDesc.FS.Source := FS_OFFSCREEN_SOURCE_METAL_IOS;
      end;
    {$ENDIF}
  else
    Assert(False)
  end;

  GOffscreenShaderDesc.vs.uniform_blocks[0].size := 64;
  GOffscreenShaderDesc.vs.uniform_blocks[0].layout := _SG_UNIFORMLAYOUT_STD140;
  if (TGfx.Backend.IsGL) then
    GOffscreenShaderDesc.vs.uniform_blocks[0].uniforms[0].Init('offscreen_params', _SG_UNIFORMTYPE_FLOAT4, 4);
  GOffscreenShaderDesc.&label := 'OffscreenShader';
end;

function OffscreenShaderDesc: PNativeShaderDesc;
begin
  if (GOffscreenShaderDesc.VS.Entry = nil) then
    InitOffscreenShaderDesc;

  Result := @GOffscreenShaderDesc;
end;

end.
